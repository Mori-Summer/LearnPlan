# Month 41: Docker容器化——C++应用的现代部署方式

## 本月主题概述

本月学习Docker容器化技术，掌握如何将C++应用打包成轻量级、可移植的容器。学习Dockerfile编写、多阶段构建、容器编排，以及如何优化C++应用的容器镜像。

**学习目标**：
- 理解Docker的核心概念和架构
- 掌握C++应用的容器化最佳实践
- 学会多阶段构建优化镜像大小
- 了解Docker Compose和基础容器编排

---

## 理论学习内容

### 第一周：Docker基础概念（35小时）

```
┌─────────────────────────────────────────────────────────────────┐
│  Week 1: Docker 基础概念与核心原理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Day 1-2: 容器化技术原理                                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  虚拟机 (VM)              容器 (Container)               │   │
│  │  ┌───────────────┐       ┌───────────────┐              │   │
│  │  │    App A      │       │    App A      │              │   │
│  │  │   Bins/Libs   │       │   Bins/Libs   │              │   │
│  │  │  Guest OS     │       └───────────────┘              │   │
│  │  │  Hypervisor   │       │ Container Runtime            │   │
│  │  │   Host OS     │       │    Host OS                   │   │
│  │  │   Hardware    │       │    Hardware                  │   │
│  │  └───────────────┘       └───────────────┘              │   │
│  │      重量级                   轻量级                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 3-4: Docker 架构与组件                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Client ←→ Docker Daemon ←→ Registry                    │   │
│  │  (docker CLI)    (dockerd)    (Docker Hub/GHCR)         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 5-7: 镜像与容器操作实践                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Image (只读模板) → Container (运行实例) → Logs/Data     │   │
│  │  Dockerfile      → docker build → docker run            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 每日任务分解

| Day | 时间 | 上午任务(2.5h) | 下午任务(2.5h) | 输出物 |
|-----|------|---------------|---------------|--------|
| 1 | 5h | 容器化技术发展历史 | 容器 vs 虚拟机原理对比 | notes/container_basics.md |
| 2 | 5h | Linux命名空间机制 | cgroups资源限制原理 | notes/linux_containers.md |
| 3 | 5h | Docker架构与组件 | Docker安装与配置 | notes/docker_architecture.md |
| 4 | 5h | 镜像管理命令实践 | 容器生命周期管理 | practice/docker_basics/ |
| 5 | 5h | 镜像分层存储原理 | Dockerfile基础语法 | notes/image_layers.md |
| 6 | 5h | 网络模式详解 | 数据卷与持久化 | notes/docker_networking.md |
| 7 | 5h | 阅读envoy Dockerfile | 分析其构建策略 | notes/envoy_analysis.md |

**学习目标**：理解容器化技术的原理

**阅读材料**：
- [ ] Docker官方文档：Get Started
- [ ] 《Docker实战》第1-4章
- [ ] Container vs Virtual Machine对比

**核心概念**：

```bash
# ==========================================
# Docker核心概念
# ==========================================

# Image（镜像）: 只读模板，包含运行应用所需的一切
# Container（容器）: 镜像的运行实例
# Dockerfile: 构建镜像的脚本
# Registry: 镜像仓库（Docker Hub, GHCR, etc.）
# Volume: 持久化数据存储
# Network: 容器间通信

# ==========================================
# 基本命令
# ==========================================

# 镜像操作
docker images                    # 列出镜像
docker pull ubuntu:22.04        # 拉取镜像
docker build -t myapp:1.0 .     # 构建镜像
docker push myrepo/myapp:1.0    # 推送镜像
docker rmi myapp:1.0            # 删除镜像

# 容器操作
docker run -it ubuntu:22.04 bash    # 交互式运行
docker run -d --name app myapp:1.0  # 后台运行
docker ps                            # 列出运行中容器
docker ps -a                         # 列出所有容器
docker logs app                      # 查看日志
docker exec -it app bash             # 进入容器
docker stop app                      # 停止容器
docker rm app                        # 删除容器

# 资源清理
docker system prune                  # 清理未使用资源
docker builder prune                 # 清理构建缓存
```

**基本Dockerfile**：

```dockerfile
# ==========================================
# 最简单的C++应用Dockerfile
# ==========================================
FROM ubuntu:22.04

# 安装编译工具
RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    && rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 复制源码
COPY . .

# 编译
RUN cmake -B build -S . -DCMAKE_BUILD_TYPE=Release \
    && cmake --build build

# 运行
CMD ["./build/myapp"]
```

#### Docker 架构原理图

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Docker 系统架构                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  客户端层 (Client)                                                  │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │    │
│  │  │docker CLI│  │docker-   │  │ Docker   │  │ SDK/API  │  │    │
│  │  │          │  │compose   │  │ Desktop  │  │ Client   │  │    │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │    │
│  └─────────────────────────┬──────────────────────────────────┘    │
│                            │ REST API / Unix Socket                 │
│                            ▼                                        │
│  守护进程层 (Docker Daemon - dockerd)                               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ┌──────────────────────────────────────────────────────┐  │    │
│  │  │               Docker Engine API                       │  │    │
│  │  └──────────────────────────────────────────────────────┘  │    │
│  │                           │                                 │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │    │
│  │  │ Image    │  │Container │  │ Network  │  │ Volume   │  │    │
│  │  │ Service  │  │ Service  │  │ Service  │  │ Service  │  │    │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │    │
│  └─────────────────────────┬──────────────────────────────────┘    │
│                            │                                        │
│                            ▼                                        │
│  容器运行时层 (Container Runtime)                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ┌──────────────────────┐  ┌──────────────────────┐       │    │
│  │  │     containerd       │  │       runc           │       │    │
│  │  │  (容器生命周期管理)   │  │  (OCI运行时实现)     │       │    │
│  │  └──────────────────────┘  └──────────────────────┘       │    │
│  └─────────────────────────┬──────────────────────────────────┘    │
│                            │                                        │
│                            ▼                                        │
│  操作系统层 (Linux Kernel)                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │    │
│  │  │Namespaces│  │ cgroups  │  │Union FS  │  │ Network  │  │    │
│  │  │ 隔离     │  │ 资源限制 │  │ 分层存储 │  │ 虚拟化  │  │    │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 容器 vs 虚拟机对比

```
┌─────────────────────────────────────────────────────────────────────┐
│               容器 vs 虚拟机 详细对比                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌───────────────────────────┐  ┌───────────────────────────┐      │
│  │      虚拟机架构           │  │       容器架构             │      │
│  ├───────────────────────────┤  ├───────────────────────────┤      │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ │  │  ┌─────┐ ┌─────┐ ┌─────┐ │      │
│  │  │App A│ │App B│ │App C│ │  │  │App A│ │App B│ │App C│ │      │
│  │  ├─────┤ ├─────┤ ├─────┤ │  │  ├─────┤ ├─────┤ ├─────┤ │      │
│  │  │Bins/│ │Bins/│ │Bins/│ │  │  │Bins/│ │Bins/│ │Bins/│ │      │
│  │  │Libs │ │Libs │ │Libs │ │  │  │Libs │ │Libs │ │Libs │ │      │
│  │  ├─────┤ ├─────┤ ├─────┤ │  │  └──┬──┘ └──┬──┘ └──┬──┘ │      │
│  │  │Guest│ │Guest│ │Guest│ │  │     └───────┼───────┘     │      │
│  │  │ OS  │ │ OS  │ │ OS  │ │  │             │             │      │
│  │  └──┬──┘ └──┬──┘ └──┬──┘ │  │  ┌──────────┴──────────┐  │      │
│  │     └───────┼───────┘    │  │  │   Container Engine  │  │      │
│  │  ┌──────────┴──────────┐ │  │  │   (Docker/containerd)│  │      │
│  │  │      Hypervisor     │ │  │  └──────────┬──────────┘  │      │
│  │  │  (VMware/KVM/Hyper-V)│ │  │             │             │      │
│  │  └──────────┬──────────┘ │  │  ┌──────────┴──────────┐  │      │
│  │  ┌──────────┴──────────┐ │  │  │      Host OS        │  │      │
│  │  │      Host OS        │ │  │  └──────────┬──────────┘  │      │
│  │  └──────────┬──────────┘ │  │  ┌──────────┴──────────┐  │      │
│  │  ┌──────────┴──────────┐ │  │  │      Hardware       │  │      │
│  │  │      Hardware       │ │  │  └─────────────────────┘  │      │
│  │  └─────────────────────┘ │  │                           │      │
│  └───────────────────────────┘  └───────────────────────────┘      │
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                         对比维度                              │  │
│  ├────────────┬─────────────────────┬───────────────────────────┤  │
│  │   维度     │      虚拟机          │        容器               │  │
│  ├────────────┼─────────────────────┼───────────────────────────┤  │
│  │ 启动时间   │ 分钟级              │ 秒级/毫秒级               │  │
│  │ 镜像大小   │ GB级                │ MB级                      │  │
│  │ 内存占用   │ 每VM占用完整OS内存  │ 共享内核，占用少          │  │
│  │ 隔离级别   │ 完全隔离（硬件级）  │ 进程级隔离                │  │
│  │ 性能损耗   │ 5-15%               │ <1%                       │  │
│  │ 移植性     │ 依赖Hypervisor      │ 跨平台（有Docker即可）    │  │
│  │ 密度       │ 每主机10-20个VM     │ 每主机100-1000+容器       │  │
│  │ 安全性     │ 高（完全隔离）      │ 较低（共享内核）          │  │
│  └────────────┴─────────────────────┴───────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### Linux 命名空间与 cgroups

```
┌─────────────────────────────────────────────────────────────────────┐
│                 Linux 容器化技术基础                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Namespaces (命名空间) - 隔离                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  ┌──────────────┐  功能: 隔离进程ID空间                     │    │
│  │  │  PID NS      │  效果: 容器内PID 1是容器主进程            │    │
│  │  └──────────────┘                                           │    │
│  │                                                             │    │
│  │  ┌──────────────┐  功能: 隔离网络栈                         │    │
│  │  │  NET NS      │  效果: 独立的IP、端口、路由表             │    │
│  │  └──────────────┘                                           │    │
│  │                                                             │    │
│  │  ┌──────────────┐  功能: 隔离文件系统挂载点                 │    │
│  │  │  MNT NS      │  效果: 容器有独立的文件系统视图           │    │
│  │  └──────────────┘                                           │    │
│  │                                                             │    │
│  │  ┌──────────────┐  功能: 隔离主机名和域名                   │    │
│  │  │  UTS NS      │  效果: 容器可以有独立的hostname           │    │
│  │  └──────────────┘                                           │    │
│  │                                                             │    │
│  │  ┌──────────────┐  功能: 隔离用户和组ID                     │    │
│  │  │  USER NS     │  效果: 容器内root映射到宿主普通用户       │    │
│  │  └──────────────┘                                           │    │
│  │                                                             │    │
│  │  ┌──────────────┐  功能: 隔离System V IPC                   │    │
│  │  │  IPC NS      │  效果: 独立的共享内存、信号量             │    │
│  │  └──────────────┘                                           │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  cgroups (控制组) - 资源限制                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  资源类型              限制能力                             │    │
│  │  ┌──────────────┐                                          │    │
│  │  │    CPU       │  限制CPU使用量、CPU核心绑定               │    │
│  │  │  --cpus=2    │  --cpu-shares 相对权重                    │    │
│  │  └──────────────┘                                          │    │
│  │                                                             │    │
│  │  ┌──────────────┐                                          │    │
│  │  │   Memory     │  限制内存使用量、触发OOM                  │    │
│  │  │  --memory=1g │  --memory-swap 交换空间                   │    │
│  │  └──────────────┘                                          │    │
│  │                                                             │    │
│  │  ┌──────────────┐                                          │    │
│  │  │   Block I/O  │  限制磁盘读写速度                         │    │
│  │  │--device-read │  --device-write-bps                       │    │
│  │  └──────────────┘                                          │    │
│  │                                                             │    │
│  │  ┌──────────────┐                                          │    │
│  │  │   PIDs       │  限制进程数量                             │    │
│  │  │ --pids-limit │  防止fork炸弹                             │    │
│  │  └──────────────┘                                          │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 镜像分层存储原理

```
┌─────────────────────────────────────────────────────────────────────┐
│                    镜像分层存储 (Union File System)                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Dockerfile                        镜像层                           │
│  ┌─────────────────────┐          ┌─────────────────────┐          │
│  │FROM ubuntu:22.04    │─────────►│ 基础层 (只读)        │ ~77MB   │
│  │                     │          │ Ubuntu 22.04        │          │
│  │RUN apt-get update   │          └─────────┬───────────┘          │
│  │    && apt-get       │                    │                       │
│  │    install -y gcc   │─────────►┌─────────┴───────────┐          │
│  │                     │          │ 依赖层 (只读)        │ +150MB  │
│  │COPY src/ /app/src/  │          │ gcc + build tools   │          │
│  │                     │          └─────────┬───────────┘          │
│  │                     │─────────►┌─────────┴───────────┐          │
│  │RUN cmake && make    │          │ 源码层 (只读)        │ +5MB    │
│  │                     │          │ 应用源码             │          │
│  │                     │          └─────────┬───────────┘          │
│  │CMD ["./app"]        │─────────►┌─────────┴───────────┐          │
│  │                     │          │ 构建层 (只读)        │ +20MB   │
│  └─────────────────────┘          │ 编译产物             │          │
│                                   └─────────┬───────────┘          │
│                                             │                       │
│  容器运行时                                 │                       │
│  ┌─────────────────────┐          ┌─────────┴───────────┐          │
│  │ 容器内文件修改      │─────────►│ 容器层 (读写)        │ 动态    │
│  │ 日志、临时文件等    │          │ Copy-on-Write       │          │
│  └─────────────────────┘          └─────────────────────┘          │
│                                                                     │
│  Copy-on-Write (写时复制) 原理:                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  1. 读取文件: 从上往下查找，找到即返回                      │    │
│  │  2. 修改文件: 复制到容器层，然后修改（原层不变）            │    │
│  │  3. 删除文件: 在容器层创建 "whiteout" 标记                  │    │
│  │  4. 创建文件: 直接写入容器层                                │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  层共享优势:                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  镜像 A: [ubuntu] + [gcc] + [app-a]   总计: ~250MB         │    │
│  │  镜像 B: [ubuntu] + [gcc] + [app-b]   总计: ~250MB         │    │
│  │  ─────────────────────────────────────────                  │    │
│  │  实际存储: [ubuntu] + [gcc] + [app-a] + [app-b] = ~275MB   │    │
│  │  节省: 225MB (相同层只存储一份)                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### Docker 网络模式详解

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Docker 网络模式                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. Bridge 模式 (默认)                                              │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Host                                                       │    │
│  │  ┌────────────────────────────────────────────────────┐    │    │
│  │  │  docker0 (172.17.0.1)                              │    │    │
│  │  │        │                                           │    │    │
│  │  │   ┌────┴────┐    ┌────────┐    ┌────────┐        │    │    │
│  │  │   │ veth    │    │ veth   │    │ veth   │        │    │    │
│  │  │   └────┬────┘    └───┬────┘    └───┬────┘        │    │    │
│  │  │  ┌─────┴─────┐ ┌─────┴────┐ ┌─────┴────┐        │    │    │
│  │  │  │Container A│ │Container B│ │Container C│        │    │    │
│  │  │  │172.17.0.2 │ │172.17.0.3│ │172.17.0.4│        │    │    │
│  │  │  └───────────┘ └──────────┘ └──────────┘        │    │    │
│  │  └────────────────────────────────────────────────────┘    │    │
│  │  特点: 容器间可通信，需要端口映射暴露服务                   │    │
│  │  命令: docker run --network bridge -p 8080:80 nginx        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  2. Host 模式                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  Host (192.168.1.100)                                       │    │
│  │  ┌────────────────────────────────────────────────────┐    │    │
│  │  │  eth0 (共享宿主网络栈)                             │    │    │
│  │  │        │                                           │    │    │
│  │  │  ┌─────┴─────┐                                     │    │    │
│  │  │  │ Container │  直接使用宿主机IP:Port              │    │    │
│  │  │  │   :80     │  无需端口映射                       │    │    │
│  │  │  └───────────┘                                     │    │    │
│  │  └────────────────────────────────────────────────────┘    │    │
│  │  特点: 性能最好，但无网络隔离，端口可能冲突                 │    │
│  │  命令: docker run --network host nginx                      │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  3. None 模式                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  ┌───────────┐                                              │    │
│  │  │ Container │  只有 lo 回环接口                           │    │
│  │  │   lo      │  完全网络隔离                               │    │
│  │  └───────────┘                                              │    │
│  │  特点: 用于安全敏感或不需要网络的场景                       │    │
│  │  命令: docker run --network none alpine                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  4. 自定义网络                                                      │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  # 创建自定义网络                                           │    │
│  │  docker network create --driver bridge my-network           │    │
│  │                                                             │    │
│  │  # 优势：                                                   │    │
│  │  # - 内置DNS：容器可通过名称互相访问                        │    │
│  │  # - 更好的隔离：不同网络的容器默认不能通信                 │    │
│  │  # - 可配置子网、网关等                                     │    │
│  │                                                             │    │
│  │  docker run --network my-network --name app1 myapp          │    │
│  │  docker run --network my-network --name app2 myapp          │    │
│  │  # app1 可以通过 "app2" 名称访问 app2                       │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### Week 1 输出物清单

| 文件 | 说明 | 完成状态 |
|------|------|---------|
| `notes/container_basics.md` | 容器化基础概念 | [ ] |
| `notes/linux_containers.md` | Linux命名空间与cgroups | [ ] |
| `notes/docker_architecture.md` | Docker架构详解 | [ ] |
| `practice/docker_basics/` | Docker基础命令练习 | [ ] |
| `notes/image_layers.md` | 镜像分层原理 | [ ] |
| `notes/docker_networking.md` | Docker网络模式 | [ ] |
| `notes/envoy_analysis.md` | Envoy Dockerfile分析 | [ ] |

#### Week 1 检验标准

- [ ] 能够解释容器与虚拟机的核心区别（隔离机制、性能、资源占用）
- [ ] 理解Docker架构的三层结构（Client/Daemon/Runtime）
- [ ] 掌握Linux命名空间的6种类型及其作用
- [ ] 理解cgroups的资源限制能力（CPU/内存/IO）
- [ ] 能够解释镜像分层存储和Copy-on-Write原理
- [ ] 掌握4种网络模式的使用场景（bridge/host/none/custom）
- [ ] 能够熟练使用docker build/run/exec/logs等基本命令
- [ ] 能够编写简单的Dockerfile

---

### 第二周：多阶段构建（35小时）

```
┌─────────────────────────────────────────────────────────────────┐
│  Week 2: 多阶段构建与镜像优化                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Day 8-9: 多阶段构建原理                                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Stage 1: Builder        Stage 2: Runtime               │   │
│  │  ┌─────────────────┐    ┌─────────────────┐            │   │
│  │  │ FROM ubuntu     │    │ FROM distroless │            │   │
│  │  │ RUN apt install │    │ COPY --from=    │            │   │
│  │  │ COPY src/       │ →  │   builder ...   │            │   │
│  │  │ RUN cmake/make  │    │                 │            │   │
│  │  │ ~1.5GB          │    │ ~50MB           │            │   │
│  │  └─────────────────┘    └─────────────────┘            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 10-11: C++ 特定优化策略                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  静态链接 vs 动态链接  │  Alpine vs Distroless vs Scratch │   │
│  │  vcpkg/Conan 依赖缓存 │  BuildKit 并行构建               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 12-14: 镜像优化实战                                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  目标: 从 1.5GB → 50MB (97%减少)                        │   │
│  │  工具: dive (分析层) / trivy (安全扫描)                 │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 每日任务分解

| Day | 时间 | 上午任务(2.5h) | 下午任务(2.5h) | 输出物 |
|-----|------|---------------|---------------|--------|
| 8 | 5h | 多阶段构建原理 | 基础多阶段Dockerfile编写 | docker/Dockerfile.basic |
| 9 | 5h | COPY --from语法详解 | 多阶段target选择 | notes/multistage_builds.md |
| 10 | 5h | 静态链接 vs 动态链接 | Alpine musl-libc注意事项 | notes/linking_strategies.md |
| 11 | 5h | 基础镜像选择对比 | distroless镜像实践 | docker/Dockerfile.distroless |
| 12 | 5h | BuildKit缓存挂载 | 并行构建优化 | docker/Dockerfile.optimized |
| 13 | 5h | dive镜像层分析 | 镜像瘦身检查清单 | notes/image_optimization.md |
| 14 | 5h | vcpkg依赖Docker缓存 | 综合优化实践 | docker/Dockerfile.production |

**学习目标**：优化C++应用的Docker镜像

**阅读材料**：
- [ ] Docker文档：Multi-stage builds
- [ ] 《Docker实战》第7章
- [ ] Distroless容器镜像

```dockerfile
# ==========================================
# 多阶段构建 - 基础版本
# ==========================================
# 构建阶段
FROM ubuntu:22.04 AS builder

RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    git \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /src
COPY . .

RUN cmake -B build -S . -DCMAKE_BUILD_TYPE=Release \
    && cmake --build build --parallel

# 运行阶段
FROM ubuntu:22.04 AS runtime

# 只安装运行时依赖
RUN apt-get update && apt-get install -y \
    libstdc++6 \
    && rm -rf /var/lib/apt/lists/*

# 创建非root用户
RUN useradd -m -s /bin/bash appuser
USER appuser

WORKDIR /app
COPY --from=builder /src/build/myapp .

ENTRYPOINT ["./myapp"]
```

```dockerfile
# ==========================================
# 多阶段构建 - 使用vcpkg
# ==========================================
FROM ubuntu:22.04 AS vcpkg-builder

RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    git \
    curl \
    zip \
    unzip \
    tar \
    pkg-config \
    && rm -rf /var/lib/apt/lists/*

# 安装vcpkg
RUN git clone https://github.com/microsoft/vcpkg.git /opt/vcpkg \
    && /opt/vcpkg/bootstrap-vcpkg.sh

ENV VCPKG_ROOT=/opt/vcpkg
ENV PATH="${VCPKG_ROOT}:${PATH}"

# 预安装依赖（利用缓存）
WORKDIR /src
COPY vcpkg.json .
RUN vcpkg install --triplet x64-linux

# 构建应用
FROM vcpkg-builder AS app-builder

COPY . .
RUN cmake -B build -S . \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake \
    && cmake --build build --parallel

# 最小运行时镜像
FROM gcr.io/distroless/cc-debian12 AS runtime

COPY --from=app-builder /src/build/myapp /app/myapp
COPY --from=app-builder /src/build/lib/*.so* /lib/

WORKDIR /app
ENTRYPOINT ["/app/myapp"]
```

```dockerfile
# ==========================================
# 多阶段构建 - 静态链接
# ==========================================
FROM alpine:3.18 AS builder

RUN apk add --no-cache \
    build-base \
    cmake \
    linux-headers \
    git

WORKDIR /src
COPY . .

# 静态链接
RUN cmake -B build -S . \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_EXE_LINKER_FLAGS="-static" \
    -DCMAKE_CXX_FLAGS="-static-libgcc -static-libstdc++" \
    && cmake --build build

# 最小镜像 - scratch
FROM scratch

COPY --from=builder /src/build/myapp /myapp

ENTRYPOINT ["/myapp"]
```

#### 多阶段构建原理图

```
┌─────────────────────────────────────────────────────────────────────┐
│                    多阶段构建工作原理                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  传统单阶段构建的问题                                               │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  FROM ubuntu:22.04                                          │    │
│  │  RUN apt-get install gcc cmake git ...    ← 构建工具 ~500MB │    │
│  │  COPY . .                                  ← 源码           │    │
│  │  RUN cmake && make                        ← 构建过程       │    │
│  │  CMD ["./app"]                                              │    │
│  │  ─────────────────────────────────────────────────────────  │    │
│  │  最终镜像: 1.5GB (包含不需要的构建工具和中间文件)            │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  多阶段构建解决方案                                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  Stage 1: builder (构建阶段)                                │    │
│  │  ┌─────────────────────────────────────────────────────┐   │    │
│  │  │  FROM ubuntu:22.04 AS builder                        │   │    │
│  │  │  RUN apt-get install gcc cmake ...                   │   │    │
│  │  │  COPY . .                                            │   │    │
│  │  │  RUN cmake && make → 产出: /app/myapp                │   │    │
│  │  │                                                      │   │    │
│  │  │  临时镜像: 1.5GB (构建完成后可丢弃)                   │   │    │
│  │  └─────────────────────────────────────────────────────┘   │    │
│  │                              │                              │    │
│  │                              │ COPY --from=builder          │    │
│  │                              ▼                              │    │
│  │  Stage 2: runtime (运行阶段)                                │    │
│  │  ┌─────────────────────────────────────────────────────┐   │    │
│  │  │  FROM gcr.io/distroless/cc                           │   │    │
│  │  │  COPY --from=builder /app/myapp /app/myapp           │   │    │
│  │  │  CMD ["/app/myapp"]                                  │   │    │
│  │  │                                                      │   │    │
│  │  │  最终镜像: 50MB (只包含应用和最小运行时)              │   │    │
│  │  └─────────────────────────────────────────────────────┘   │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  多阶段构建进阶用法                                                 │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  # 选择性构建特定阶段                                       │    │
│  │  docker build --target builder -t myapp:builder .           │    │
│  │  docker build --target runtime -t myapp:latest .            │    │
│  │                                                             │    │
│  │  # 从外部镜像复制文件                                       │    │
│  │  COPY --from=nginx:alpine /etc/nginx/nginx.conf /etc/       │    │
│  │                                                             │    │
│  │  # 使用命名阶段引用                                         │    │
│  │  FROM builder AS tester                                     │    │
│  │  RUN ctest                                                  │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 基础镜像选择对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                 C++ 应用基础镜像选择指南                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              基础镜像对比表                                    │  │
│  ├────────────┬───────────┬───────────────────┬─────────────────┤  │
│  │   镜像     │  大小     │   C++运行时支持    │   适用场景       │  │
│  ├────────────┼───────────┼───────────────────┼─────────────────┤  │
│  │ ubuntu     │ ~77MB     │ 完整glibc+libstdc++│ 开发、调试      │  │
│  │ :22.04     │           │ apt可安装任何依赖  │ 需要shell       │  │
│  ├────────────┼───────────┼───────────────────┼─────────────────┤  │
│  │ debian     │ ~80MB     │ 同ubuntu          │ 同ubuntu        │  │
│  │ :slim      │ ~50MB     │ 精简版            │ 生产环境        │  │
│  ├────────────┼───────────┼───────────────────┼─────────────────┤  │
│  │ alpine     │ ~5MB      │ musl-libc (非glibc)│ 极小镜像需求    │  │
│  │ :3.18      │           │ 需静态链接或musl编译│ 注意兼容性问题  │  │
│  ├────────────┼───────────┼───────────────────┼─────────────────┤  │
│  │ distroless │ ~2MB      │ 仅运行时库        │ 生产环境最佳    │  │
│  │ /cc        │ +libc     │ 无shell/包管理器  │ 安全敏感场景    │  │
│  ├────────────┼───────────┼───────────────────┼─────────────────┤  │
│  │ scratch    │ 0MB       │ 无               │ 纯静态链接应用  │  │
│  │            │           │ 需完全静态编译    │ 最小攻击面      │  │
│  └────────────┴───────────┴───────────────────┴─────────────────┘  │
│                                                                     │
│  选择决策树                                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  需要shell调试? ─Yes→ ubuntu/debian                        │    │
│  │       │No                                                   │    │
│  │       ▼                                                     │    │
│  │  可以静态编译? ─Yes→ scratch (最小最安全)                   │    │
│  │       │No                                                   │    │
│  │       ▼                                                     │    │
│  │  使用glibc? ─Yes→ distroless/cc (推荐)                     │    │
│  │       │No                                                   │    │
│  │       ▼                                                     │    │
│  │  alpine + musl编译 (需要测试兼容性)                        │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Alpine + musl-libc 注意事项                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  问题:                                                      │    │
│  │  - glibc编译的程序不能直接在Alpine运行                      │    │
│  │  - 某些第三方库没有musl版本                                 │    │
│  │  - DNS解析行为可能不同                                      │    │
│  │  - 线程栈大小默认值不同                                     │    │
│  │                                                             │    │
│  │  解决方案:                                                  │    │
│  │  1. 在Alpine中编译: FROM alpine AS builder                  │    │
│  │  2. 完全静态链接: -static -static-libgcc -static-libstdc++  │    │
│  │  3. 使用gcompat: apk add gcompat (glibc兼容层)             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### BuildKit 特性详解

```dockerfile
# ==========================================
# BuildKit 高级特性示例
# ==========================================
# syntax=docker/dockerfile:1.4

# 启用BuildKit: export DOCKER_BUILDKIT=1

# 特性1: 缓存挂载 (--mount=type=cache)
# 缓存包管理器下载，跨构建持久化
FROM ubuntu:22.04 AS builder

# apt缓存挂载 - 避免每次重新下载包
RUN --mount=type=cache,target=/var/cache/apt \
    --mount=type=cache,target=/var/lib/apt \
    apt-get update && apt-get install -y \
    build-essential \
    cmake \
    git

# vcpkg缓存挂载 - 复用已下载的依赖
ENV VCPKG_ROOT=/opt/vcpkg
RUN git clone https://github.com/microsoft/vcpkg.git ${VCPKG_ROOT} \
    && ${VCPKG_ROOT}/bootstrap-vcpkg.sh

WORKDIR /src
COPY vcpkg.json .

# 挂载vcpkg下载缓存和二进制缓存
RUN --mount=type=cache,target=/root/.cache/vcpkg \
    ${VCPKG_ROOT}/vcpkg install

# 特性2: Secret挂载 (--mount=type=secret)
# 安全地使用敏感信息，不会留在镜像层中
# docker build --secret id=mytoken,src=token.txt .
RUN --mount=type=secret,id=mytoken \
    cat /run/secrets/mytoken | ./authenticate.sh

# 特性3: SSH挂载 (--mount=type=ssh)
# 使用宿主机SSH密钥，不泄露到镜像
# docker build --ssh default .
RUN --mount=type=ssh \
    git clone git@github.com:private/repo.git

# 特性4: 绑定挂载 (--mount=type=bind)
# 只读挂载文件，不复制到镜像层
RUN --mount=type=bind,source=scripts,target=/scripts \
    /scripts/setup.sh

# 特性5: 并行构建
# 多个FROM自动并行执行（无依赖关系时）
FROM alpine AS config
COPY config/ /config/

FROM builder AS app
COPY --from=config /config/ /app/config/
COPY src/ /src/
RUN cmake -B build && cmake --build build

# 以上config和builder阶段会并行执行

# 特性6: Here-Documents (内联文件)
RUN <<EOF
set -e
cmake -B build -S .
cmake --build build --parallel
cmake --install build --prefix /opt/app
EOF

COPY <<-"CONFIG" /app/config.yaml
server:
  host: 0.0.0.0
  port: 8080
CONFIG
```

#### 镜像优化检查清单

```
┌─────────────────────────────────────────────────────────────────────┐
│                    镜像优化检查清单                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ✅ 构建阶段优化                                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 使用多阶段构建，分离构建和运行环境                      │    │
│  │  [ ] 选择合适的基础镜像（distroless/alpine/scratch）        │    │
│  │  [ ] 使用BuildKit缓存挂载加速依赖安装                       │    │
│  │  [ ] 合并RUN指令，减少镜像层数                              │    │
│  │  [ ] 将变化少的指令放在前面，利用构建缓存                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 依赖优化                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 只安装运行时必需的依赖                                 │    │
│  │  [ ] 清理包管理器缓存: rm -rf /var/lib/apt/lists/*          │    │
│  │  [ ] 使用 --no-install-recommends 避免安装建议包            │    │
│  │  [ ] 考虑静态链接减少运行时依赖                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 文件优化                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 使用.dockerignore排除不需要的文件                      │    │
│  │  [ ] 不复制文档、测试文件、.git目录                         │    │
│  │  [ ] 只COPY需要的文件，避免COPY .                           │    │
│  │  [ ] 使用strip去除二进制符号表                              │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 安全优化                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 使用非root用户运行应用                                 │    │
│  │  [ ] 不在镜像中包含敏感信息（密钥、密码）                   │    │
│  │  [ ] 使用--mount=type=secret处理构建时密钥                  │    │
│  │  [ ] 定期扫描镜像漏洞（trivy/grype）                        │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  优化效果示例                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  优化前 (ubuntu + 构建工具 + 应用):     1.5 GB              │    │
│  │  ↓ 多阶段构建                                               │    │
│  │  ubuntu runtime + 应用:                  200 MB             │    │
│  │  ↓ 换用debian:slim                                          │    │
│  │  debian:slim + 应用:                     120 MB             │    │
│  │  ↓ 换用distroless                                           │    │
│  │  distroless/cc + 应用:                   50 MB              │    │
│  │  ↓ 完全静态链接                                             │    │
│  │  scratch + 静态应用:                     15 MB              │    │
│  │                                                             │    │
│  │  减少: 99% (1.5GB → 15MB)                                  │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

```bash
# ==========================================
# 镜像分析工具
# ==========================================

# 使用dive分析镜像层
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    wagoodman/dive myapp:latest

# dive分析结果解读:
# - 查看每层大小和内容
# - 识别潜在的浪费空间
# - 检查重复文件
# - 效率评分

# 使用trivy扫描安全漏洞
docker run --rm \
    -v /var/run/docker.sock:/var/run/docker.sock \
    aquasec/trivy image myapp:latest

# 检查镜像历史
docker history --no-trunc myapp:latest

# 检查镜像大小
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

#### Week 2 输出物清单

| 文件 | 说明 | 完成状态 |
|------|------|---------|
| `docker/Dockerfile.basic` | 基础多阶段Dockerfile | [ ] |
| `notes/multistage_builds.md` | 多阶段构建详解 | [ ] |
| `notes/linking_strategies.md` | 静态/动态链接策略 | [ ] |
| `docker/Dockerfile.distroless` | Distroless镜像实践 | [ ] |
| `docker/Dockerfile.optimized` | BuildKit优化版 | [ ] |
| `notes/image_optimization.md` | 镜像优化指南 | [ ] |
| `docker/Dockerfile.production` | 生产级Dockerfile | [ ] |

#### Week 2 检验标准

- [ ] 能够解释多阶段构建的原理和优势
- [ ] 掌握COPY --from语法和target选择
- [ ] 理解静态链接与动态链接在容器中的权衡
- [ ] 能够选择合适的基础镜像（根据场景）
- [ ] 掌握BuildKit的缓存挂载、secret挂载等高级特性
- [ ] 能够使用dive分析镜像层
- [ ] 能够将镜像从GB级优化到MB级
- [ ] 完成镜像优化检查清单的所有项目

---

### 第三周：Docker Compose与服务编排（35小时）

```
┌─────────────────────────────────────────────────────────────────┐
│  Week 3: Docker Compose 多容器应用编排                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Day 15-16: Compose 基础与服务定义                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  docker-compose.yml                                      │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐                 │   │
│  │  │  app    │  │  db     │  │  redis  │                 │   │
│  │  │  :8080  │←→│  :5432  │  │  :6379  │                 │   │
│  │  └─────────┘  └─────────┘  └─────────┘                 │   │
│  │       ↑            ↑            ↑                       │   │
│  │       └────────────┼────────────┘                       │   │
│  │              backend network                            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 17-18: 网络、存储与依赖管理                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  networks: 服务隔离与通信                                │   │
│  │  volumes:  数据持久化                                    │   │
│  │  depends_on + healthcheck: 启动顺序控制                  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 19-21: 多环境配置与实战                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  docker-compose.yml        (基础配置)                   │   │
│  │  docker-compose.override.yml (开发环境)                  │   │
│  │  docker-compose.prod.yml   (生产环境)                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 每日任务分解

| Day | 时间 | 上午任务(2.5h) | 下午任务(2.5h) | 输出物 |
|-----|------|---------------|---------------|--------|
| 15 | 5h | Compose Specification学习 | services基本配置 | docker/docker-compose.yml |
| 16 | 5h | build配置与镜像管理 | 端口映射与环境变量 | notes/compose_services.md |
| 17 | 5h | networks配置详解 | 服务间DNS与通信 | notes/compose_networking.md |
| 18 | 5h | volumes类型与配置 | 数据持久化策略 | notes/compose_volumes.md |
| 19 | 5h | depends_on与healthcheck | 启动顺序最佳实践 | notes/service_dependencies.md |
| 20 | 5h | 多环境配置管理 | override与profiles | docker/docker-compose.*.yml |
| 21 | 5h | 完整微服务编排实践 | 日志与调试技巧 | practice/compose_demo/ |

**学习目标**：使用Docker Compose管理多容器应用

**阅读材料**：
- [ ] Docker Compose文档
- [ ] 《Docker实战》第9-10章
- [ ] Compose Specification

```yaml
# ==========================================
# docker-compose.yml - 完整示例
# ==========================================
version: '3.9'

services:
  # C++应用服务
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: runtime
      args:
        BUILD_TYPE: Release
    image: myapp:latest
    container_name: myapp
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - LOG_LEVEL=info
      - DB_HOST=postgres
      - REDIS_HOST=redis
    volumes:
      - app-data:/app/data
      - ./config:/app/config:ro
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_started
    networks:
      - backend
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 256M

  # PostgreSQL数据库
  postgres:
    image: postgres:15-alpine
    container_name: postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DB_USER:-app}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-secret}
      POSTGRES_DB: ${DB_NAME:-appdb}
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    networks:
      - backend
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-app}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    command: redis-server --appendonly yes
    volumes:
      - redis-data:/data
    networks:
      - backend

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/nginx/certs:ro
    depends_on:
      - app
    networks:
      - frontend
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true

volumes:
  app-data:
  postgres-data:
  redis-data:
```

```yaml
# ==========================================
# docker-compose.override.yml - 开发环境覆盖
# ==========================================
version: '3.9'

services:
  app:
    build:
      target: builder  # 使用构建阶段作为开发环境
    volumes:
      - .:/src  # 挂载源码
      - build-cache:/src/build  # 缓存构建目录
    environment:
      - LOG_LEVEL=debug
    command: ["./build/myapp", "--dev"]

  # 开发工具
  dev-tools:
    image: ubuntu:22.04
    volumes:
      - .:/src
    working_dir: /src
    command: sleep infinity

volumes:
  build-cache:
```

```bash
# ==========================================
# Docker Compose常用命令
# ==========================================

# 启动服务
docker-compose up -d

# 查看状态
docker-compose ps

# 查看日志
docker-compose logs -f app

# 重新构建
docker-compose build --no-cache

# 停止并删除
docker-compose down

# 带数据卷删除
docker-compose down -v

# 扩展服务实例
docker-compose up -d --scale app=3

# 执行命令
docker-compose exec app bash

# 重启单个服务
docker-compose restart app
```

#### Compose 服务依赖与启动顺序

```
┌─────────────────────────────────────────────────────────────────────┐
│                服务依赖与启动顺序控制                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  depends_on 的局限性                                                │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  depends_on: [postgres]  # 只等待容器启动，不等待服务就绪   │    │
│  │                                                             │    │
│  │  问题场景:                                                  │    │
│  │  ┌──────────┐     ┌──────────┐                            │    │
│  │  │ postgres │ →   │   app    │                            │    │
│  │  │ 容器启动 │     │ 尝试连接 │ → 失败！(postgres还在初始化) │    │
│  │  │ (0.5s)  │     │  数据库  │                            │    │
│  │  └──────────┘     └──────────┘                            │    │
│  │  PostgreSQL需要~10-30秒完成初始化                          │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  解决方案: depends_on + condition                                   │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  services:                                                  │    │
│  │    postgres:                                                │    │
│  │      image: postgres:15                                     │    │
│  │      healthcheck:                                           │    │
│  │        test: ["CMD-SHELL", "pg_isready -U postgres"]       │    │
│  │        interval: 5s                                         │    │
│  │        timeout: 5s                                          │    │
│  │        retries: 5                                           │    │
│  │                                                             │    │
│  │    app:                                                     │    │
│  │      depends_on:                                            │    │
│  │        postgres:                                            │    │
│  │          condition: service_healthy  # 等待健康检查通过     │    │
│  │        redis:                                               │    │
│  │          condition: service_started  # 只等待启动          │    │
│  │                                                             │    │
│  │  可选condition:                                             │    │
│  │  - service_started: 容器启动即可 (默认)                    │    │
│  │  - service_healthy: 等待healthcheck通过                    │    │
│  │  - service_completed_successfully: 等待容器成功退出        │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  启动顺序可视化                                                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  T=0s     T=5s      T=15s     T=20s                        │    │
│  │    │        │         │         │                          │    │
│  │    ▼        ▼         ▼         ▼                          │    │
│  │  postgres  postgres  postgres  app                          │    │
│  │  启动      初始化中   healthy   启动                        │    │
│  │    │                    │         │                          │    │
│  │  redis ────────────────→│         │                          │    │
│  │  (并行启动)              │         │                          │    │
│  │                         └─────────→ depends_on满足后启动app │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### Volume 类型与使用场景

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Volume 类型详解                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. Named Volumes (命名卷) - 推荐用于持久化数据                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  volumes:                                                   │    │
│  │    postgres-data:       # 声明命名卷                        │    │
│  │      driver: local                                          │    │
│  │                                                             │    │
│  │  services:                                                  │    │
│  │    postgres:                                                │    │
│  │      volumes:                                               │    │
│  │        - postgres-data:/var/lib/postgresql/data            │    │
│  │                                                             │    │
│  │  优点: Docker管理存储位置，跨平台一致，可备份               │    │
│  │  位置: /var/lib/docker/volumes/projectname_postgres-data/  │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  2. Bind Mounts (绑定挂载) - 用于开发时代码同步                     │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  services:                                                  │    │
│  │    app:                                                     │    │
│  │      volumes:                                               │    │
│  │        - ./src:/app/src         # 相对路径                  │    │
│  │        - /home/user/config:/config  # 绝对路径              │    │
│  │        - ./config:/app/config:ro    # 只读挂载              │    │
│  │                                                             │    │
│  │  优点: 实时同步宿主机文件，开发调试方便                     │    │
│  │  缺点: 依赖宿主机路径，跨平台可能有问题                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  3. tmpfs (临时文件系统) - 用于敏感或临时数据                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  services:                                                  │    │
│  │    app:                                                     │    │
│  │      tmpfs:                                                 │    │
│  │        - /tmp                                               │    │
│  │        - /run:size=100m  # 限制大小                        │    │
│  │                                                             │    │
│  │  特点: 存储在内存中，容器停止后消失                        │    │
│  │  用途: 临时文件、缓存、敏感数据（避免写入磁盘）            │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  Volume 挂载选项                                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  长语法 (推荐):                                             │    │
│  │  volumes:                                                   │    │
│  │    - type: volume                                           │    │
│  │      source: mydata                                         │    │
│  │      target: /data                                          │    │
│  │      read_only: true                                        │    │
│  │      volume:                                                │    │
│  │        nocopy: true    # 不复制容器原有内容                 │    │
│  │                                                             │    │
│  │    - type: bind                                             │    │
│  │      source: ./config                                       │    │
│  │      target: /app/config                                    │    │
│  │      read_only: true                                        │    │
│  │      bind:                                                  │    │
│  │        create_host_path: true  # 宿主机路径不存在则创建    │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 多环境配置管理

```yaml
# ==========================================
# docker-compose.yml - 基础配置（所有环境共用）
# ==========================================
version: '3.9'

services:
  app:
    build:
      context: .
      dockerfile: docker/Dockerfile
    networks:
      - backend

  postgres:
    image: postgres:15-alpine
    networks:
      - backend

  redis:
    image: redis:7-alpine
    networks:
      - backend

networks:
  backend:

# ==========================================
# docker-compose.override.yml - 开发环境（自动加载）
# ==========================================
version: '3.9'

services:
  app:
    build:
      target: development
    volumes:
      - .:/src                    # 源码挂载
      - build-cache:/src/build    # 构建缓存
    environment:
      - LOG_LEVEL=debug
      - DEV_MODE=true
    ports:
      - "8080:8080"               # 暴露端口
      - "9229:9229"               # 调试端口

  postgres:
    environment:
      POSTGRES_PASSWORD: devpassword
    ports:
      - "5432:5432"               # 开发时暴露数据库

volumes:
  build-cache:

# ==========================================
# docker-compose.prod.yml - 生产环境
# ==========================================
version: '3.9'

services:
  app:
    build:
      target: production
    environment:
      - LOG_LEVEL=info
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2'
          memory: 1G
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  postgres:
    environment:
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    secrets:
      - db_password
    # 不暴露端口到宿主机

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/prod.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app

secrets:
  db_password:
    file: ./secrets/db_password.txt
```

```bash
# ==========================================
# 多环境使用命令
# ==========================================

# 开发环境（自动加载 docker-compose.yml + docker-compose.override.yml）
docker-compose up -d

# 生产环境（指定配置文件）
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 使用环境变量切换
# .env 文件
COMPOSE_FILE=docker-compose.yml:docker-compose.prod.yml
docker-compose up -d

# 使用profiles选择性启动服务
# docker-compose.yml:
#   services:
#     debug-tools:
#       profiles: ["debug"]
#     monitoring:
#       profiles: ["prod"]

docker-compose --profile debug up -d     # 启动包含debug profile的服务
docker-compose --profile prod up -d      # 启动包含prod profile的服务
```

#### Week 3 输出物清单

| 文件 | 说明 | 完成状态 |
|------|------|---------|
| `docker/docker-compose.yml` | 基础Compose配置 | [ ] |
| `notes/compose_services.md` | 服务配置详解 | [ ] |
| `notes/compose_networking.md` | 网络配置详解 | [ ] |
| `notes/compose_volumes.md` | 存储配置详解 | [ ] |
| `notes/service_dependencies.md` | 服务依赖控制 | [ ] |
| `docker/docker-compose.*.yml` | 多环境配置文件 | [ ] |
| `practice/compose_demo/` | 完整编排练习 | [ ] |

#### Week 3 检验标准

- [ ] 能够编写完整的docker-compose.yml定义多服务应用
- [ ] 理解services/networks/volumes的配置语法
- [ ] 掌握depends_on + healthcheck控制启动顺序
- [ ] 能够区分三种volume类型的使用场景
- [ ] 掌握多环境配置管理（override/多文件/profiles）
- [ ] 能够使用docker-compose命令管理应用生命周期
- [ ] 理解Compose网络中的服务发现机制（DNS）
- [ ] 能够调试Compose应用（logs/exec/ps）

---

### 第四周：生产环境最佳实践（35小时）

```
┌─────────────────────────────────────────────────────────────────┐
│  Week 4: 生产环境 Docker 最佳实践                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Day 22-23: 容器安全加固                                         │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  安全检查清单:                                           │   │
│  │  ✓ 非root用户运行    ✓ 只读文件系统                     │   │
│  │  ✓ 最小化能力        ✓ 资源限制                         │   │
│  │  ✓ 镜像扫描          ✓ 网络隔离                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 24-25: 日志、监控与资源管理                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  stdout/stderr → 日志驱动 → ELK/Loki                    │   │
│  │  cAdvisor/Prometheus → 资源监控 → Grafana               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  Day 26-28: 容器编排与 CI/CD 集成                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Docker Swarm (简单) / Kubernetes (企业级)               │   │
│  │  GitHub Actions + Docker → 自动构建 → GHCR → 部署       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 每日任务分解

| Day | 时间 | 上午任务(2.5h) | 下午任务(2.5h) | 输出物 |
|-----|------|---------------|---------------|--------|
| 22 | 5h | 容器安全原则 | 非root用户配置 | notes/container_security.md |
| 23 | 5h | 能力限制与seccomp | 只读文件系统实践 | docker/Dockerfile.secure |
| 24 | 5h | 日志收集策略 | stdout/stderr最佳实践 | notes/container_logging.md |
| 25 | 5h | 资源限制配置 | Prometheus监控集成 | docker-compose.monitoring.yml |
| 26 | 5h | Docker Swarm基础 | 服务编排概念 | notes/container_orchestration.md |
| 27 | 5h | Kubernetes核心概念 | Pod/Deployment/Service | notes/k8s_basics.md |
| 28 | 5h | CI/CD Docker集成 | 综合项目部署 | 完整部署流程 |

**学习目标**：掌握生产级Docker部署技巧

**阅读材料**：
- [ ] Docker安全最佳实践
- [ ] 容器镜像优化指南
- [ ] Kubernetes基础概念

```dockerfile
# ==========================================
# 生产级Dockerfile
# ==========================================
# syntax=docker/dockerfile:1.4

# 基础构建镜像
FROM ubuntu:22.04 AS base

# 安装CA证书和时区数据
RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    tzdata \
    && rm -rf /var/lib/apt/lists/*

# 构建阶段
FROM base AS builder

# 安装构建依赖
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    cmake \
    ninja-build \
    git \
    curl \
    zip \
    unzip \
    pkg-config \
    && rm -rf /var/lib/apt/lists/*

# 安装vcpkg
ARG VCPKG_COMMIT=a34c873a9717a888f58dc05268dea15592c2f0ff
RUN git clone https://github.com/microsoft/vcpkg.git /opt/vcpkg \
    && cd /opt/vcpkg \
    && git checkout ${VCPKG_COMMIT} \
    && ./bootstrap-vcpkg.sh -disableMetrics

ENV VCPKG_ROOT=/opt/vcpkg

# 缓存vcpkg依赖
WORKDIR /src
COPY vcpkg.json vcpkg-configuration.json ./
RUN --mount=type=cache,target=/root/.cache/vcpkg \
    ${VCPKG_ROOT}/vcpkg install --triplet x64-linux

# 复制源码并构建
COPY . .

ARG BUILD_TYPE=Release
ARG BUILD_VERSION=dev

RUN --mount=type=cache,target=/src/build \
    cmake -B build -S . -G Ninja \
    -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
    -DCMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake \
    -DVERSION_STRING=${BUILD_VERSION} \
    && cmake --build build --parallel \
    && cmake --install build --prefix /opt/app

# 运行时镜像
FROM base AS runtime

# 安全设置
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# 复制应用
COPY --from=builder /opt/app /opt/app

# 复制运行时依赖库（如果需要）
# COPY --from=builder /src/build/lib/*.so* /usr/local/lib/
# RUN ldconfig

WORKDIR /opt/app
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD ["/opt/app/bin/healthcheck"]

# 暴露端口
EXPOSE 8080

# 入口点
ENTRYPOINT ["/opt/app/bin/myapp"]
CMD ["--config", "/opt/app/config/default.yaml"]

# 元数据标签
LABEL org.opencontainers.image.title="MyApp" \
      org.opencontainers.image.description="My C++ Application" \
      org.opencontainers.image.version="${BUILD_VERSION}" \
      org.opencontainers.image.source="https://github.com/user/myapp"
```

```dockerfile
# ==========================================
# .dockerignore
# ==========================================
# 版本控制
.git
.gitignore
.gitattributes

# 构建目录
build/
cmake-build-*/
out/

# IDE配置
.idea/
.vscode/
*.swp
*.swo

# 文档
docs/
*.md
LICENSE

# 测试
tests/
*_test.cpp

# CI/CD配置
.github/
.gitlab-ci.yml
Jenkinsfile

# Docker相关（避免递归）
Dockerfile*
docker-compose*
.docker/

# 其他
*.log
*.tmp
.env.local
```

**安全扫描和优化**：

```bash
# ==========================================
# 镜像安全扫描
# ==========================================

# 使用Trivy扫描漏洞
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
    aquasec/trivy image myapp:latest

# 使用Dive分析镜像层
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    wagoodman/dive myapp:latest

# 检查镜像大小
docker images myapp

# 查看镜像历史
docker history myapp:latest

# ==========================================
# 镜像优化技巧
# ==========================================

# 1. 使用小基础镜像
# ubuntu:22.04    ~77MB
# debian:slim     ~80MB
# alpine          ~5MB
# distroless      ~2MB
# scratch         0MB

# 2. 合并RUN指令
# 不好的做法
RUN apt-get update
RUN apt-get install -y package1
RUN apt-get install -y package2

# 好的做法
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    && rm -rf /var/lib/apt/lists/*

# 3. 使用.dockerignore减少上下文

# 4. 利用构建缓存
# 将变化少的层放在前面

# 5. 使用多阶段构建
# 只复制必要文件到最终镜像
```

#### 容器安全加固检查清单

```
┌─────────────────────────────────────────────────────────────────────┐
│                    容器安全加固检查清单                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ✅ 用户权限                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 使用非root用户运行容器                                 │    │
│  │      USER appuser  # Dockerfile中指定                       │    │
│  │      docker run --user 1000:1000  # 运行时指定              │    │
│  │                                                             │    │
│  │  [ ] 禁止容器内提权                                         │    │
│  │      docker run --security-opt=no-new-privileges            │    │
│  │                                                             │    │
│  │  [ ] 使用User Namespace映射（可选）                         │    │
│  │      docker run --userns=host                               │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 能力限制 (Capabilities)                                         │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 删除所有默认能力                                       │    │
│  │      docker run --cap-drop=ALL                              │    │
│  │                                                             │    │
│  │  [ ] 只添加必需能力                                         │    │
│  │      docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE  │    │
│  │                                                             │    │
│  │  常用能力:                                                  │    │
│  │  - NET_BIND_SERVICE: 绑定<1024端口                         │    │
│  │  - CHOWN: 改变文件所有权                                    │    │
│  │  - SETUID/SETGID: 改变用户/组ID                            │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 文件系统安全                                                    │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 只读根文件系统                                         │    │
│  │      docker run --read-only                                 │    │
│  │                                                             │    │
│  │  [ ] 必要时挂载tmpfs用于写入                                │    │
│  │      docker run --read-only --tmpfs /tmp --tmpfs /run       │    │
│  │                                                             │    │
│  │  [ ] 敏感目录只读挂载                                       │    │
│  │      volumes: ["./config:/app/config:ro"]                   │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 网络安全                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 使用内部网络隔离后端服务                               │    │
│  │      networks:                                              │    │
│  │        backend:                                             │    │
│  │          internal: true  # 无法访问外网                     │    │
│  │                                                             │    │
│  │  [ ] 只暴露必需端口                                         │    │
│  │      ports: ["127.0.0.1:8080:8080"]  # 只绑定localhost     │    │
│  │                                                             │    │
│  │  [ ] 禁用ICC（容器间通信）如非必需                          │    │
│  │      docker network create --opt com.docker.network.bridge.enable_icc=false mynet│
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  ✅ 资源限制                                                        │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │  [ ] 限制内存使用                                           │    │
│  │      docker run --memory=512m --memory-swap=512m           │    │
│  │                                                             │    │
│  │  [ ] 限制CPU使用                                            │    │
│  │      docker run --cpus=1.5                                  │    │
│  │                                                             │    │
│  │  [ ] 限制进程数                                             │    │
│  │      docker run --pids-limit=100                           │    │
│  │                                                             │    │
│  │  [ ] 限制重启次数                                           │    │
│  │      docker run --restart=on-failure:5                     │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 日志收集与监控

```
┌─────────────────────────────────────────────────────────────────────┐
│                    容器日志与监控策略                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  日志最佳实践                                                       │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  1. 应用日志输出到stdout/stderr                            │    │
│  │  ┌─────────────────────────────────────────────────────┐   │    │
│  │  │  // C++应用中                                        │   │    │
│  │  │  spdlog::set_default_logger(                         │   │    │
│  │  │      spdlog::stdout_color_mt("console"));           │   │    │
│  │  │                                                      │   │    │
│  │  │  // 不要写入文件：/var/log/app.log ❌                 │   │    │
│  │  │  // 输出到标准输出：stdout ✅                         │   │    │
│  │  └─────────────────────────────────────────────────────┘   │    │
│  │                                                             │    │
│  │  2. Docker日志驱动处理                                      │    │
│  │  ┌─────────────────────────────────────────────────────┐   │    │
│  │  │  # 默认json-file驱动                                 │   │    │
│  │  │  docker run --log-driver json-file \                │   │    │
│  │  │    --log-opt max-size=10m \                         │   │    │
│  │  │    --log-opt max-file=3 myapp                       │   │    │
│  │  │                                                      │   │    │
│  │  │  # 发送到Fluentd                                     │   │    │
│  │  │  docker run --log-driver fluentd \                  │   │    │
│  │  │    --log-opt fluentd-address=localhost:24224 myapp  │   │    │
│  │  └─────────────────────────────────────────────────────┘   │    │
│  │                                                             │    │
│  │  3. 结构化日志格式                                          │    │
│  │  ┌─────────────────────────────────────────────────────┐   │    │
│  │  │  // JSON格式日志便于解析                             │   │    │
│  │  │  {"timestamp":"2024-01-15T10:30:00Z",               │   │    │
│  │  │   "level":"info",                                   │   │    │
│  │  │   "message":"Request processed",                    │   │    │
│  │  │   "request_id":"abc123",                            │   │    │
│  │  │   "duration_ms":45}                                 │   │    │
│  │  └─────────────────────────────────────────────────────┘   │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  监控架构                                                           │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │    ┌─────────┐                                             │    │
│  │    │Container│──metrics──┐                                 │    │
│  │    │  app    │           │                                 │    │
│  │    └─────────┘           │                                 │    │
│  │                          ▼                                 │    │
│  │    ┌─────────┐      ┌─────────┐      ┌─────────┐          │    │
│  │    │cAdvisor │─────►│Prometheus│─────►│ Grafana │          │    │
│  │    │(容器指标)│      │ (存储)  │      │ (展示)  │          │    │
│  │    └─────────┘      └─────────┘      └─────────┘          │    │
│  │                                                             │    │
│  │  关键指标:                                                  │    │
│  │  - container_cpu_usage_seconds_total                       │    │
│  │  - container_memory_usage_bytes                            │    │
│  │  - container_network_receive/transmit_bytes_total         │    │
│  │  - container_fs_reads/writes_bytes_total                  │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### 容器编排概览

```
┌─────────────────────────────────────────────────────────────────────┐
│                    容器编排技术对比                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Docker Compose vs Docker Swarm vs Kubernetes                       │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                                                               │  │
│  │  ┌─────────────────────────────────────────────────────────┐ │  │
│  │  │           Docker Compose                                 │ │  │
│  │  ├─────────────────────────────────────────────────────────┤ │  │
│  │  │  范围: 单机多容器                                        │ │  │
│  │  │  复杂度: 低                                              │ │  │
│  │  │  适用: 开发环境、小型部署                                │ │  │
│  │  │  特点: 简单配置文件、快速启动                            │ │  │
│  │  └─────────────────────────────────────────────────────────┘ │  │
│  │                           │                                   │  │
│  │                           ▼                                   │  │
│  │  ┌─────────────────────────────────────────────────────────┐ │  │
│  │  │           Docker Swarm                                   │ │  │
│  │  ├─────────────────────────────────────────────────────────┤ │  │
│  │  │  范围: 多机集群                                          │ │  │
│  │  │  复杂度: 中                                              │ │  │
│  │  │  适用: 中小型生产环境                                    │ │  │
│  │  │  特点: 原生Docker支持、Compose文件兼容                   │ │  │
│  │  └─────────────────────────────────────────────────────────┘ │  │
│  │                           │                                   │  │
│  │                           ▼                                   │  │
│  │  ┌─────────────────────────────────────────────────────────┐ │  │
│  │  │           Kubernetes (K8s)                               │ │  │
│  │  ├─────────────────────────────────────────────────────────┤ │  │
│  │  │  范围: 大规模集群                                        │ │  │
│  │  │  复杂度: 高                                              │ │  │
│  │  │  适用: 企业级生产环境                                    │ │  │
│  │  │  特点: 自动扩缩容、滚动更新、服务发现、配置管理          │ │  │
│  │  └─────────────────────────────────────────────────────────┘ │  │
│  │                                                               │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  Kubernetes 核心概念                                                │
│  ┌────────────────────────────────────────────────────────────┐    │
│  │                                                             │    │
│  │  Pod: 最小部署单位，包含一个或多个容器                      │    │
│  │  ┌─────────────────────────────────────────────┐           │    │
│  │  │  Pod                                        │           │    │
│  │  │  ┌───────────┐  ┌───────────┐              │           │    │
│  │  │  │ Container │  │ Container │  共享网络/存储│           │    │
│  │  │  │   (app)   │  │  (sidecar)│              │           │    │
│  │  │  └───────────┘  └───────────┘              │           │    │
│  │  └─────────────────────────────────────────────┘           │    │
│  │                                                             │    │
│  │  Deployment: 管理Pod副本，支持滚动更新                      │    │
│  │  ┌─────────────────────────────────────────────┐           │    │
│  │  │  Deployment (replicas: 3)                   │           │    │
│  │  │  ┌─────┐  ┌─────┐  ┌─────┐                │           │    │
│  │  │  │ Pod │  │ Pod │  │ Pod │  自动维护副本数│           │    │
│  │  │  └─────┘  └─────┘  └─────┘                │           │    │
│  │  └─────────────────────────────────────────────┘           │    │
│  │                                                             │    │
│  │  Service: 提供稳定的访问入口，负载均衡                     │    │
│  │  ┌─────────────────────────────────────────────┐           │    │
│  │  │         Service (ClusterIP/LoadBalancer)    │           │    │
│  │  │                    │                        │           │    │
│  │  │         ┌──────────┼──────────┐            │           │    │
│  │  │         ▼          ▼          ▼            │           │    │
│  │  │      Pod 1      Pod 2      Pod 3           │           │    │
│  │  └─────────────────────────────────────────────┘           │    │
│  │                                                             │    │
│  └────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

#### CI/CD 中的 Docker 最佳实践

```yaml
# ==========================================
# GitHub Actions + Docker 完整工作流
# ==========================================
name: Docker CI/CD

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 设置BuildKit
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 构建测试镜像（利用缓存）
      - name: Build test image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: tester
          load: true
          tags: test-image
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 运行测试
      - name: Run tests
        run: docker run --rm test-image

  build-and-push:
    needs: build-and-test
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 登录镜像仓库
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 生成镜像标签
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha

      # 构建并推送
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          target: production
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ github.ref_name }}

  # 安全扫描
  security-scan:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
```

#### Week 4 输出物清单

| 文件 | 说明 | 完成状态 |
|------|------|---------|
| `notes/container_security.md` | 容器安全最佳实践 | [ ] |
| `docker/Dockerfile.secure` | 安全加固的Dockerfile | [ ] |
| `notes/container_logging.md` | 日志收集策略 | [ ] |
| `docker-compose.monitoring.yml` | 监控栈配置 | [ ] |
| `notes/container_orchestration.md` | 编排技术对比 | [ ] |
| `notes/k8s_basics.md` | Kubernetes基础 | [ ] |
| `完整部署流程` | CI/CD + Docker集成 | [ ] |

#### Week 4 检验标准

- [ ] 掌握容器安全加固的关键措施（非root/能力限制/只读文件系统）
- [ ] 能够配置容器资源限制（CPU/内存/进程数）
- [ ] 理解容器日志最佳实践（stdout/stderr + 日志驱动）
- [ ] 能够配置基本的Prometheus监控栈
- [ ] 了解Docker Swarm和Kubernetes的核心概念
- [ ] 能够在GitHub Actions中配置Docker构建和推送
- [ ] 能够使用Trivy进行镜像安全扫描
- [ ] 理解Month 40 CI/CD与Docker的集成方式

---

## 源码阅读任务

### 本月源码阅读

1. **官方示例项目**
   - docker-library/official-images
   - GoogleContainerTools/distroless

2. **C++项目Docker化示例**
   - envoyproxy/envoy 的Dockerfile
   - grpc/grpc 的Docker配置

3. **构建工具**
   - BuildKit源码理解
   - docker/buildx

---

## 实践项目

### 项目：容器化的微服务应用

创建一个容器化的C++微服务应用，包含完整的Docker配置。

**项目结构**：

```
microservice-demo/
├── docker/
│   ├── Dockerfile
│   ├── Dockerfile.dev
│   └── docker-compose.yml
├── src/
│   ├── main.cpp
│   ├── server.hpp
│   ├── server.cpp
│   ├── handler.hpp
│   └── handler.cpp
├── include/
│   └── microservice/
│       └── api.hpp
├── tests/
│   └── test_server.cpp
├── config/
│   ├── default.yaml
│   └── production.yaml
├── scripts/
│   ├── build.sh
│   └── healthcheck.sh
├── CMakeLists.txt
├── vcpkg.json
└── README.md
```

**docker/Dockerfile**：

```dockerfile
# syntax=docker/dockerfile:1.4

###################
# 基础镜像
###################
FROM ubuntu:22.04 AS base

RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

###################
# 构建环境
###################
FROM base AS build-env

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    cmake \
    ninja-build \
    git \
    curl \
    zip \
    unzip \
    pkg-config \
    && rm -rf /var/lib/apt/lists/*

# vcpkg
ARG VCPKG_COMMIT
ENV VCPKG_ROOT=/opt/vcpkg
RUN git clone https://github.com/microsoft/vcpkg.git ${VCPKG_ROOT} \
    && cd ${VCPKG_ROOT} \
    && git checkout ${VCPKG_COMMIT:-HEAD} \
    && ./bootstrap-vcpkg.sh -disableMetrics

###################
# 依赖缓存
###################
FROM build-env AS deps

WORKDIR /src
COPY vcpkg.json vcpkg-configuration.json ./

RUN --mount=type=cache,target=/root/.cache/vcpkg \
    ${VCPKG_ROOT}/vcpkg install --triplet x64-linux

###################
# 构建应用
###################
FROM deps AS builder

COPY . .

ARG BUILD_TYPE=Release
ARG VERSION=dev

RUN cmake -B build -S . -G Ninja \
    -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
    -DCMAKE_TOOLCHAIN_FILE=${VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake \
    -DAPP_VERSION=${VERSION}

RUN cmake --build build --parallel $(nproc)

RUN cmake --install build --prefix /opt/microservice

###################
# 测试
###################
FROM builder AS tester

RUN ctest --test-dir build --output-on-failure

###################
# 生产镜像
###################
FROM base AS production

# 安全配置
RUN groupadd -r microservice && useradd -r -g microservice service
RUN mkdir -p /opt/microservice/data && chown -R service:microservice /opt/microservice

# 复制构建产物
COPY --from=builder --chown=service:microservice /opt/microservice /opt/microservice

# 复制配置
COPY --chown=service:microservice config/production.yaml /opt/microservice/config/config.yaml

WORKDIR /opt/microservice
USER service

EXPOSE 8080 9090

HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD ["/opt/microservice/bin/healthcheck"]

ENTRYPOINT ["/opt/microservice/bin/microservice"]
CMD ["--config", "/opt/microservice/config/config.yaml"]

###################
# 开发镜像
###################
FROM build-env AS development

# 安装开发工具
RUN apt-get update && apt-get install -y --no-install-recommends \
    gdb \
    valgrind \
    clang-format \
    clang-tidy \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /src

# 复制vcpkg依赖
COPY --from=deps ${VCPKG_ROOT} ${VCPKG_ROOT}
COPY --from=deps /src/vcpkg_installed /src/vcpkg_installed

CMD ["bash"]
```

**src/server.hpp**：

```cpp
#pragma once

#include <string>
#include <memory>
#include <functional>
#include <atomic>

namespace microservice {

struct ServerConfig {
    std::string host = "0.0.0.0";
    uint16_t http_port = 8080;
    uint16_t grpc_port = 9090;
    size_t thread_count = 4;
    std::string log_level = "info";
};

class Server {
public:
    explicit Server(ServerConfig config);
    ~Server();

    // 禁止拷贝
    Server(const Server&) = delete;
    Server& operator=(const Server&) = delete;

    // 启动服务
    void start();

    // 停止服务
    void stop();

    // 等待停止
    void wait();

    // 检查是否运行中
    bool is_running() const;

    // 健康检查
    struct HealthStatus {
        bool healthy;
        std::string version;
        int64_t uptime_seconds;
        size_t active_connections;
    };
    HealthStatus health_check() const;

private:
    class Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace microservice
```

**src/server.cpp**：

```cpp
#include "server.hpp"

#include <boost/asio.hpp>
#include <boost/beast.hpp>
#include <spdlog/spdlog.h>
#include <nlohmann/json.hpp>

#include <thread>
#include <chrono>

namespace microservice {

namespace asio = boost::asio;
namespace beast = boost::beast;
namespace http = beast::http;
using tcp = asio::ip::tcp;
using json = nlohmann::json;

class Server::Impl : public std::enable_shared_from_this<Server::Impl> {
public:
    explicit Impl(ServerConfig config)
        : config_(std::move(config))
        , ioc_(config_.thread_count)
        , acceptor_(ioc_)
        , start_time_(std::chrono::steady_clock::now())
    {}

    void start() {
        // 设置日志级别
        spdlog::set_level(spdlog::level::from_str(config_.log_level));

        // 设置acceptor
        tcp::endpoint endpoint(
            asio::ip::make_address(config_.host),
            config_.http_port
        );

        acceptor_.open(endpoint.protocol());
        acceptor_.set_option(asio::socket_base::reuse_address(true));
        acceptor_.bind(endpoint);
        acceptor_.listen();

        spdlog::info("Server starting on {}:{}", config_.host, config_.http_port);

        // 开始接受连接
        do_accept();

        // 启动工作线程
        running_ = true;
        for (size_t i = 0; i < config_.thread_count; ++i) {
            threads_.emplace_back([this] {
                ioc_.run();
            });
        }
    }

    void stop() {
        if (!running_.exchange(false)) return;

        spdlog::info("Server stopping...");

        acceptor_.close();
        ioc_.stop();

        for (auto& t : threads_) {
            if (t.joinable()) t.join();
        }
        threads_.clear();

        spdlog::info("Server stopped");
    }

    void wait() {
        for (auto& t : threads_) {
            if (t.joinable()) t.join();
        }
    }

    bool is_running() const {
        return running_.load();
    }

    HealthStatus health_check() const {
        auto now = std::chrono::steady_clock::now();
        auto uptime = std::chrono::duration_cast<std::chrono::seconds>(
            now - start_time_).count();

        return {
            .healthy = running_.load(),
            .version = "1.0.0",
            .uptime_seconds = uptime,
            .active_connections = active_connections_.load()
        };
    }

private:
    void do_accept() {
        acceptor_.async_accept(
            asio::make_strand(ioc_),
            [self = shared_from_this()](beast::error_code ec, tcp::socket socket) {
                if (!ec) {
                    self->active_connections_++;
                    self->handle_connection(std::move(socket));
                }
                if (self->running_) {
                    self->do_accept();
                }
            }
        );
    }

    void handle_connection(tcp::socket socket) {
        auto buffer = std::make_shared<beast::flat_buffer>();
        auto request = std::make_shared<http::request<http::string_body>>();

        http::async_read(socket, *buffer, *request,
            [this, socket = std::move(socket), buffer, request]
            (beast::error_code ec, std::size_t) mutable {
                if (ec) {
                    active_connections_--;
                    return;
                }

                handle_request(*request, socket);
                active_connections_--;
            }
        );
    }

    void handle_request(const http::request<http::string_body>& req,
                        tcp::socket& socket) {
        http::response<http::string_body> res;
        res.version(req.version());
        res.keep_alive(req.keep_alive());

        if (req.target() == "/health") {
            auto status = health_check();
            json j = {
                {"healthy", status.healthy},
                {"version", status.version},
                {"uptime_seconds", status.uptime_seconds},
                {"active_connections", status.active_connections}
            };

            res.result(http::status::ok);
            res.set(http::field::content_type, "application/json");
            res.body() = j.dump();
        } else if (req.target() == "/api/v1/data") {
            if (req.method() == http::verb::get) {
                json j = {{"message", "Hello from microservice!"}};
                res.result(http::status::ok);
                res.set(http::field::content_type, "application/json");
                res.body() = j.dump();
            } else {
                res.result(http::status::method_not_allowed);
            }
        } else {
            res.result(http::status::not_found);
            res.body() = "Not Found";
        }

        res.prepare_payload();
        http::write(socket, res);
    }

    ServerConfig config_;
    asio::io_context ioc_;
    tcp::acceptor acceptor_;
    std::vector<std::thread> threads_;
    std::atomic<bool> running_{false};
    std::atomic<size_t> active_connections_{0};
    std::chrono::steady_clock::time_point start_time_;
};

Server::Server(ServerConfig config)
    : impl_(std::make_shared<Impl>(std::move(config))) {}

Server::~Server() {
    stop();
}

void Server::start() { impl_->start(); }
void Server::stop() { impl_->stop(); }
void Server::wait() { impl_->wait(); }
bool Server::is_running() const { return impl_->is_running(); }
Server::HealthStatus Server::health_check() const { return impl_->health_check(); }

} // namespace microservice
```

**src/main.cpp**：

```cpp
#include "server.hpp"

#include <spdlog/spdlog.h>
#include <yaml-cpp/yaml.h>

#include <csignal>
#include <iostream>
#include <filesystem>

namespace {
    std::unique_ptr<microservice::Server> g_server;

    void signal_handler(int signal) {
        spdlog::info("Received signal {}, shutting down...", signal);
        if (g_server) {
            g_server->stop();
        }
    }
}

microservice::ServerConfig load_config(const std::string& path) {
    microservice::ServerConfig config;

    if (!std::filesystem::exists(path)) {
        spdlog::warn("Config file not found: {}, using defaults", path);
        return config;
    }

    try {
        YAML::Node yaml = YAML::LoadFile(path);

        if (yaml["server"]) {
            auto server = yaml["server"];
            if (server["host"]) config.host = server["host"].as<std::string>();
            if (server["http_port"]) config.http_port = server["http_port"].as<uint16_t>();
            if (server["grpc_port"]) config.grpc_port = server["grpc_port"].as<uint16_t>();
            if (server["thread_count"]) config.thread_count = server["thread_count"].as<size_t>();
        }

        if (yaml["logging"]) {
            auto logging = yaml["logging"];
            if (logging["level"]) config.log_level = logging["level"].as<std::string>();
        }
    } catch (const YAML::Exception& e) {
        spdlog::error("Failed to parse config: {}", e.what());
        throw;
    }

    return config;
}

int main(int argc, char* argv[]) {
    std::string config_path = "/opt/microservice/config/config.yaml";

    // 解析命令行参数
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "--config" && i + 1 < argc) {
            config_path = argv[++i];
        } else if (arg == "--help") {
            std::cout << "Usage: " << argv[0] << " [--config <path>]\n";
            return 0;
        }
    }

    // 设置信号处理
    std::signal(SIGINT, signal_handler);
    std::signal(SIGTERM, signal_handler);

    try {
        auto config = load_config(config_path);

        spdlog::info("Starting microservice...");
        spdlog::info("  Host: {}", config.host);
        spdlog::info("  HTTP Port: {}", config.http_port);
        spdlog::info("  Threads: {}", config.thread_count);

        g_server = std::make_unique<microservice::Server>(config);
        g_server->start();
        g_server->wait();

    } catch (const std::exception& e) {
        spdlog::error("Fatal error: {}", e.what());
        return 1;
    }

    return 0;
}
```

**scripts/healthcheck.sh**：

```bash
#!/bin/bash
set -e

# 健康检查脚本
curl -sf http://localhost:8080/health | jq -e '.healthy == true' > /dev/null
```

**config/production.yaml**：

```yaml
server:
  host: "0.0.0.0"
  http_port: 8080
  grpc_port: 9090
  thread_count: 4

logging:
  level: "info"

database:
  host: "${DB_HOST:-localhost}"
  port: ${DB_PORT:-5432}
  name: "${DB_NAME:-microservice}"

redis:
  host: "${REDIS_HOST:-localhost}"
  port: ${REDIS_PORT:-6379}
```

---

## 月度验收标准

### 知识掌握

- [ ] 能够解释容器与虚拟机的核心区别（隔离机制、性能、资源占用）
- [ ] 理解Docker架构的三层结构（Client/Daemon/containerd+runc）
- [ ] 掌握Linux命名空间（6种）和cgroups的作用
- [ ] 能够解释镜像分层存储和Copy-on-Write原理

### 实践能力

- [ ] 能够编写生产级多阶段构建Dockerfile
- [ ] 能够将镜像从GB级优化到MB级（选择合适基础镜像、使用BuildKit特性）
- [ ] 能够编写完整的docker-compose.yml定义多服务应用
- [ ] 掌握depends_on + healthcheck控制启动顺序
- [ ] 能够配置三种volume类型并理解其使用场景

### 安全与运维

- [ ] 能够实施容器安全加固（非root用户/能力限制/资源限制）
- [ ] 理解容器日志最佳实践（stdout/stderr + 日志驱动）
- [ ] 能够配置基本的监控栈（Prometheus/cAdvisor）
- [ ] 能够在CI/CD中集成Docker构建和推送

### 综合项目检验

- [ ] 完整的容器化微服务项目能正常构建和运行
- [ ] 镜像大小<100MB（C++应用）
- [ ] 通过Trivy安全扫描无高危漏洞
- [ ] docker-compose up能正确启动所有服务
- [ ] 服务间能通过服务名相互访问

### 知识检验问题

1. **多阶段构建的优势是什么？**
   - 分离构建环境和运行环境
   - 最终镜像只包含运行时必需的文件
   - 大幅减小镜像体积（从GB到MB）
   - 提高安全性（不包含构建工具）

2. **如何减小Docker镜像的大小？**
   - 使用多阶段构建
   - 选择小基础镜像（distroless/alpine/scratch）
   - 合并RUN指令，清理缓存
   - 使用.dockerignore排除不需要的文件
   - 考虑静态链接
   - 使用strip去除符号表

3. **ENTRYPOINT和CMD的区别是什么？**
   - ENTRYPOINT: 定义容器启动时执行的命令，不易被覆盖
   - CMD: 为ENTRYPOINT提供默认参数，易被docker run参数覆盖
   - 最佳实践: ENTRYPOINT设置主命令，CMD设置默认参数
   - `ENTRYPOINT ["./app"]` + `CMD ["--config", "default.yaml"]`

4. **如何在容器中处理信号？**
   - 确保应用是PID 1或使用tini作为init进程
   - 捕获SIGTERM信号进行优雅关闭
   - 设置适当的stop_grace_period（默认10秒）
   - 使用exec形式而非shell形式运行命令
   - `ENTRYPOINT ["./app"]` (exec形式，信号直达)
   - `ENTRYPOINT ./app` (shell形式，信号发给shell)

5. **bridge网络和host网络的区别？**
   - bridge: 容器有独立网络栈，需要端口映射，有NAT开销
   - host: 共享宿主机网络栈，性能最好，但无网络隔离

6. **如何控制Compose服务启动顺序？**
   - depends_on默认只等待容器启动
   - depends_on + condition: service_healthy等待健康检查通过
   - 需要在被依赖服务上配置healthcheck

7. **Named Volume和Bind Mount的区别？**
   - Named Volume: Docker管理，跨平台一致，适合持久化数据
   - Bind Mount: 指向宿主机路径，实时同步，适合开发时挂载源码

8. **为什么要使用非root用户运行容器？**
   - 最小权限原则
   - 防止容器逃逸时获得宿主机root权限
   - 满足安全合规要求

9. **BuildKit缓存挂载的优势？**
   - --mount=type=cache持久化包管理器缓存
   - 跨构建复用下载的包，加速构建
   - 不会增加镜像层大小

10. **Docker Compose vs Kubernetes的选择？**
    - Compose: 单机/小规模，简单配置，快速启动
    - Kubernetes: 大规模集群，自动扩缩容，滚动更新，完整的生态系统

---

### 本月知识图谱

```
┌─────────────────────────────────────────────────────────────────────┐
│              Month 41: Docker 容器化知识体系                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  基础层 (Week 1)                                                    │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐              │
│  │容器原理  │ │Docker    │ │Namespaces│ │  镜像    │              │
│  │vs虚拟机 │ │架构      │ │& cgroups │ │分层存储  │              │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘              │
│       └────────────┴────────────┴────────────┘                     │
│                         │                                           │
│  构建层 (Week 2)        ▼                                           │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐              │
│  │多阶段   │ │基础镜像  │ │BuildKit  │ │ 镜像优化 │              │
│  │构建     │ │选择      │ │特性      │ │ 策略    │              │
│  │COPY     │ │distroless│ │缓存挂载  │ │静态链接 │              │
│  │--from   │ │scratch   │ │并行构建  │ │dive分析 │              │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘              │
│       └────────────┴────────────┴────────────┘                     │
│                         │                                           │
│  编排层 (Week 3)        ▼                                           │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐              │
│  │Compose   │ │ Networks │ │ Volumes  │ │ 多环境  │              │
│  │服务定义  │ │ 服务发现 │ │ 持久化   │ │ 配置    │              │
│  │depends_on│ │ DNS      │ │ 类型选择 │ │override │              │
│  │healthcheck│ 内部网络  │ │          │ │profiles │              │
│  └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘              │
│       └────────────┴────────────┴────────────┘                     │
│                         │                                           │
│  生产层 (Week 4)        ▼                                           │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐              │
│  │ 安全加固 │ │ 日志监控 │ │ 编排对比 │ │ CI/CD   │              │
│  │非root    │ │stdout    │ │Swarm     │ │集成     │              │
│  │能力限制  │ │Prometheus│ │Kubernetes│ │Actions  │              │
│  │资源限制  │ │Grafana   │ │Pod/Svc   │ │GHCR     │              │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘              │
│                                                                     │
│  ═══════════════════════════════════════════════════════════════   │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │            完整的容器化 C++ 微服务应用                        │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │   │
│  │  │Dockerfile│  │compose  │  │监控栈   │  │CI/CD    │        │   │
│  │  │多阶段    │  │多服务   │  │日志     │  │自动构建 │        │   │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘        │   │
│  │  + 安全加固 + 镜像优化 (<100MB) + GitHub Actions集成        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  与 Month 40 (CI/CD) 的衔接:                                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Month 40: GitHub Actions Workflow                          │   │
│  │       │                                                      │   │
│  │       ▼                                                      │   │
│  │  Month 41: Docker构建 → 推送GHCR → 部署                     │   │
│  │       │                                                      │   │
│  │       ▼                                                      │   │
│  │  Month 42+: 测试、性能优化、更多云原生技术                   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 输出物清单

### Week 1 输出物

| 文件 | 说明 | 类型 |
|------|------|------|
| `notes/container_basics.md` | 容器化基础概念 | 笔记 |
| `notes/linux_containers.md` | Linux命名空间与cgroups | 笔记 |
| `notes/docker_architecture.md` | Docker架构详解 | 笔记 |
| `practice/docker_basics/` | Docker基础命令练习 | 练习 |
| `notes/image_layers.md` | 镜像分层原理 | 笔记 |
| `notes/docker_networking.md` | Docker网络模式 | 笔记 |
| `notes/envoy_analysis.md` | Envoy Dockerfile分析 | 笔记 |

### Week 2 输出物

| 文件 | 说明 | 类型 |
|------|------|------|
| `docker/Dockerfile.basic` | 基础多阶段Dockerfile | 配置 |
| `notes/multistage_builds.md` | 多阶段构建详解 | 笔记 |
| `notes/linking_strategies.md` | 静态/动态链接策略 | 笔记 |
| `docker/Dockerfile.distroless` | Distroless镜像实践 | 配置 |
| `docker/Dockerfile.optimized` | BuildKit优化版 | 配置 |
| `notes/image_optimization.md` | 镜像优化指南 | 笔记 |
| `docker/Dockerfile.production` | 生产级Dockerfile | 配置 |

### Week 3 输出物

| 文件 | 说明 | 类型 |
|------|------|------|
| `docker/docker-compose.yml` | 基础Compose配置 | 配置 |
| `notes/compose_services.md` | 服务配置详解 | 笔记 |
| `notes/compose_networking.md` | 网络配置详解 | 笔记 |
| `notes/compose_volumes.md` | 存储配置详解 | 笔记 |
| `notes/service_dependencies.md` | 服务依赖控制 | 笔记 |
| `docker/docker-compose.*.yml` | 多环境配置文件 | 配置 |
| `practice/compose_demo/` | 完整编排练习 | 练习 |

### Week 4 输出物

| 文件 | 说明 | 类型 |
|------|------|------|
| `notes/container_security.md` | 容器安全最佳实践 | 笔记 |
| `docker/Dockerfile.secure` | 安全加固的Dockerfile | 配置 |
| `notes/container_logging.md` | 日志收集策略 | 笔记 |
| `docker-compose.monitoring.yml` | 监控栈配置 | 配置 |
| `notes/container_orchestration.md` | 编排技术对比 | 笔记 |
| `notes/k8s_basics.md` | Kubernetes基础 | 笔记 |

### 综合输出物

| 文件 | 说明 | 类型 |
|------|------|------|
| `microservice-demo/` | 完整的容器化微服务 | 项目 |
| `notes/month41_docker.md` | 月度学习总结 | 笔记 |
| `docs/DOCKER_GUIDE.md` | Docker使用指南 | 文档 |
| `scripts/build.sh` | 构建脚本 | 脚本 |
| `scripts/healthcheck.sh` | 健康检查脚本 | 脚本 |

---

## 时间分配表

| 周次 | 主题 | 理论学习 | 实践编码 | 源码阅读 |
|------|------|----------|----------|----------|
| 第1周 | Docker基础概念 | 15h | 15h | 5h |
| 第2周 | 多阶段构建 | 12h | 18h | 5h |
| 第3周 | Docker Compose | 10h | 20h | 5h |
| 第4周 | 生产最佳实践 | 8h | 22h | 5h |
| **合计** | | **45h** | **75h** | **20h** |

**学习时间细分**：

| 活动 | 时间 | 说明 |
|------|------|------|
| 阅读官方文档 | 15h | Docker/Compose/BuildKit文档 |
| 阅读《Docker实战》 | 10h | 容器化理论基础 |
| 源码阅读分析 | 20h | envoy/grpc等项目的Dockerfile |
| Dockerfile编写 | 25h | 多阶段构建、优化实践 |
| Compose编排 | 20h | 服务定义、网络、存储 |
| 安全与监控 | 15h | 安全加固、日志、监控栈 |
| 微服务项目 | 25h | 综合实践项目 |
| 文档整理 | 10h | 笔记和指南编写 |
| **总计** | **140h** | |

---

## 下月预告

Month 42将学习**单元测试（Google Test/Catch2）**，掌握C++项目的测试驱动开发和测试框架使用。

```
Month 40 (CI/CD)           Month 41 (Docker)          Month 42 (Testing)
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│ GitHub Actions  │       │ 容器化部署       │       │ 单元测试        │
│ CI/CD流水线     │  →    │ Dockerfile      │  →    │ Google Test    │
│ 自动化构建测试   │       │ 多阶段构建       │       │ Catch2         │
│ Release发布     │       │ docker-compose  │       │ Mock/Stub      │
│ Docker推送      │       │ 安全与监控       │       │ TDD实践        │
└─────────────────┘       └─────────────────┘       └─────────────────┘
        │                         │                         │
        └─────────────────────────┴─────────────────────────┘
                                  │
                                  ▼
                    ┌─────────────────────────────┐
                    │    完整的现代 C++ 工程体系    │
                    │  构建 + 测试 + 容器化 + CI/CD │
                    └─────────────────────────────┘
```

Month 40-42构成完整的现代C++工程实践：
- Month 40: CI/CD自动化流水线
- Month 41: Docker容器化部署
- Month 42: 单元测试与质量保障

三者结合实现：代码提交 → 自动测试 → 构建镜像 → 部署发布的完整DevOps流程。
