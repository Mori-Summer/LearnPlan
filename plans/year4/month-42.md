# Month 42: 单元测试——Google Test与Catch2实践

## 本月主题概述

本月深入学习C++单元测试，重点掌握两大主流测试框架：Google Test和Catch2。学习测试驱动开发（TDD）的实践方法，掌握Mock对象、参数化测试、测试夹具等高级技术。

**学习目标**：
- 掌握Google Test和Catch2的使用方法
- 理解单元测试的设计原则（FIRST原则）
- 学会使用Mock进行依赖隔离
- 能够实现代码覆盖率分析

---

## 理论学习内容

### 第一周：Google Test基础

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Week 1: Google Test基础                                   │
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Day 1-2    │───▶│  Day 3-4    │───▶│  Day 5-6    │───▶│   Day 7     │  │
│  │ GTest安装   │    │ 断言系统    │    │ 测试夹具    │    │ 命令行与    │  │
│  │ 基本结构    │    │ 完整掌握    │    │ 生命周期    │    │ 最佳实践    │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│                                                                             │
│  核心技能：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ • TEST/TEST_F宏的使用              • 六类断言的场景选择                │ │
│  │ • EXPECT vs ASSERT的决策           • SetUp/TearDown生命周期            │ │
│  │ • 测试发现与过滤机制               • 测试组织与命名规范                │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  输出物：gtest_basics/项目 + 笔记                          学习时间：35小时 │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 1 每日任务分解

| 天数 | 时间 | 主题 | 具体任务 | 输出物 |
|------|------|------|----------|--------|
| Day 1 | 5h | GTest环境搭建 | 1. vcpkg安装gtest 2. CMake集成配置 3. 运行第一个测试 4. 理解测试发现机制 | 可运行的GTest项目模板 |
| Day 2 | 5h | 测试基本结构 | 1. TEST宏深入理解 2. TestSuite组织 3. AAA模式（Arrange-Act-Assert） 4. 测试命名规范 | 基础测试用例集 |
| Day 3 | 5h | 断言系统(上) | 1. 布尔断言（TRUE/FALSE） 2. 比较断言（EQ/NE/LT/LE/GT/GE） 3. EXPECT vs ASSERT决策 | 断言分类练习代码 |
| Day 4 | 5h | 断言系统(下) | 1. 字符串断言（STREQ/STRNE） 2. 浮点断言（FLOAT_EQ/NEAR） 3. 异常断言（THROW/NO_THROW） 4. 谓词断言（PRED） | 完整断言示例库 |
| Day 5 | 5h | 测试夹具基础 | 1. TEST_F宏使用 2. SetUp/TearDown 3. 成员变量共享 4. 辅助函数编写 | 夹具模式示例 |
| Day 6 | 5h | 高级夹具技术 | 1. SetUpTestSuite/TearDownTestSuite 2. 环境类(Environment) 3. 夹具继承与组合 | 复杂夹具示例 |
| Day 7 | 5h | 命令行与实践 | 1. 命令行参数详解 2. 测试过滤与选择 3. 输出格式控制 4. Week 1总结 | 测试运行脚本+笔记 |

---

**学习目标**：掌握Google Test的核心功能

**阅读材料**：
- [ ] Google Test官方文档
- [ ] 《Google软件测试之道》相关章节
- [ ] gtest-primer

**核心概念**：

#### 测试金字塔——测试策略基础

```
                        ┌───────────────┐
                       ╱                 ╲
                      ╱    E2E Tests      ╲     少量、慢、昂贵
                     ╱   (端到端测试)       ╲    验证完整用户场景
                    ╱─────────────────────────╲
                   ╱                           ╲
                  ╱    Integration Tests        ╲   中等数量
                 ╱      (集成测试)               ╲  验证模块协作
                ╱─────────────────────────────────╲
               ╱                                   ╲
              ╱         Unit Tests                  ╲  大量、快、便宜
             ╱          (单元测试)                   ╲ 验证独立单元
            ╱───────────────────────────────────────────╲

┌────────────────────────────────────────────────────────────────────────────┐
│ 测试金字塔最佳比例（按数量）：                                               │
│                                                                            │
│   单元测试     : 集成测试 : E2E测试  =  70% : 20% : 10%                     │
│                                                                            │
│ 单元测试特点：                                                              │
│   ✓ 执行速度快（毫秒级）          ✓ 独立运行，无外部依赖                    │
│   ✓ 失败时精确定位问题            ✓ 易于编写和维护                          │
│   ✓ 适合TDD开发流程               ✓ 高代码覆盖率                            │
└────────────────────────────────────────────────────────────────────────────┘
```

#### Google Test架构原理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Google Test 架构                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     UnitTest (单例)                                  │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │  管理所有测试的执行，维护测试结果统计                          │    │   │
│  │  └─────────────────────────────────────────────────────────────┘    │   │
│  └──────────────────────────────┬──────────────────────────────────────┘   │
│                                 │ 包含多个                                  │
│                                 ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   TestSuite (测试套件)                               │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │  TEST(SuiteName, TestName) 中的 SuiteName                     │    │   │
│  │  │  同一套件共享 SetUpTestSuite/TearDownTestSuite                 │    │   │
│  │  └─────────────────────────────────────────────────────────────┘    │   │
│  └──────────────────────────────┬──────────────────────────────────────┘   │
│                                 │ 包含多个                                  │
│                                 ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    TestInfo (测试信息)                               │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │  TEST(SuiteName, TestName) 中的 TestName                      │    │   │
│  │  │  每个测试独立的 SetUp/TearDown                                 │    │   │
│  │  └─────────────────────────────────────────────────────────────┘    │   │
│  └──────────────────────────────┬──────────────────────────────────────┘   │
│                                 │ 产生                                      │
│                                 ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   TestResult (测试结果)                              │   │
│  │  ┌─────────────────────────────────────────────────────────────┐    │   │
│  │  │  passed/failed/skipped 状态                                    │    │   │
│  │  │  TestPartResult 列表（每个断言的结果）                          │    │   │
│  │  └─────────────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  执行流程：                                                                  │
│  ┌────────┐   ┌────────────┐   ┌──────────┐   ┌────────┐   ┌────────────┐ │
│  │ 注册   │──▶│ 过滤/排序   │──▶│ SetUp    │──▶│ 执行   │──▶│ TearDown   │ │
│  │ 测试   │   │ 测试       │   │ 初始化   │   │ 断言   │   │ 清理       │ │
│  └────────┘   └────────────┘   └──────────┘   └────────┘   └────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

```cpp
// ==========================================
// 基本测试结构
// ==========================================
#include <gtest/gtest.h>

// 简单测试
TEST(TestSuiteName, TestName) {
    // Arrange - 准备
    int a = 1, b = 2;

    // Act - 执行
    int result = a + b;

    // Assert - 断言
    EXPECT_EQ(result, 3);
}

// ==========================================
// 常用断言宏
// ==========================================

// 基本断言（失败时继续执行）
EXPECT_TRUE(condition);
EXPECT_FALSE(condition);
EXPECT_EQ(val1, val2);      // ==
EXPECT_NE(val1, val2);      // !=
EXPECT_LT(val1, val2);      // <
EXPECT_LE(val1, val2);      // <=
EXPECT_GT(val1, val2);      // >
EXPECT_GE(val1, val2);      // >=

// 致命断言（失败时终止当前测试）
ASSERT_TRUE(condition);
ASSERT_EQ(val1, val2);
// ... 其他ASSERT_*与EXPECT_*对应

// 字符串断言
EXPECT_STREQ(str1, str2);   // C字符串相等
EXPECT_STRNE(str1, str2);   // C字符串不等
EXPECT_STRCASEEQ(s1, s2);   // 忽略大小写相等

// 浮点数断言
EXPECT_FLOAT_EQ(val1, val2);
EXPECT_DOUBLE_EQ(val1, val2);
EXPECT_NEAR(val1, val2, abs_error);

// 异常断言
EXPECT_THROW(statement, exception_type);
EXPECT_ANY_THROW(statement);
EXPECT_NO_THROW(statement);

// 谓词断言
EXPECT_PRED1(pred, val1);
EXPECT_PRED2(pred, val1, val2);
// 或使用lambda
EXPECT_PRED_FORMAT1(formatter, val1);
```

#### 断言分类详解

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        GTest 断言分类体系                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      1. 布尔断言 (Boolean)                           │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  EXPECT_TRUE(condition)      │  条件为真                             │   │
│  │  EXPECT_FALSE(condition)     │  条件为假                             │   │
│  │  适用场景：is_valid()、empty()、contains() 等返回bool的函数          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      2. 比较断言 (Comparison)                        │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  EXPECT_EQ(val1, val2)  ==   │  EXPECT_NE(val1, val2)  !=           │   │
│  │  EXPECT_LT(val1, val2)  <    │  EXPECT_LE(val1, val2)  <=           │   │
│  │  EXPECT_GT(val1, val2)  >    │  EXPECT_GE(val1, val2)  >=           │   │
│  │  适用场景：数值比较、枚举值、指针地址                                 │   │
│  │  注意：EQ 比较指针时比较地址，不是内容                                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      3. 字符串断言 (String)                          │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  EXPECT_STREQ(s1, s2)        │  C字符串相等（区分大小写）            │   │
│  │  EXPECT_STRNE(s1, s2)        │  C字符串不等                          │   │
│  │  EXPECT_STRCASEEQ(s1, s2)    │  C字符串相等（忽略大小写）            │   │
│  │  EXPECT_STRCASENE(s1, s2)    │  C字符串不等（忽略大小写）            │   │
│  │  注意：std::string 使用 EXPECT_EQ 即可                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      4. 浮点断言 (Floating-Point)                    │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  EXPECT_FLOAT_EQ(v1, v2)     │  float相等（4 ULPs误差）              │   │
│  │  EXPECT_DOUBLE_EQ(v1, v2)    │  double相等（4 ULPs误差）             │   │
│  │  EXPECT_NEAR(v1, v2, error)  │  绝对误差范围内相等                   │   │
│  │  永远不要用 == 比较浮点数！ULP = Units in the Last Place            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      5. 异常断言 (Exception)                         │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  EXPECT_THROW(stmt, type)    │  抛出指定类型异常                     │   │
│  │  EXPECT_ANY_THROW(stmt)      │  抛出任意异常                         │   │
│  │  EXPECT_NO_THROW(stmt)       │  不抛出异常                           │   │
│  │  适用场景：边界条件、错误处理路径                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      6. 谓词断言 (Predicate)                         │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  EXPECT_PRED1(pred, v1)      │  一元谓词 pred(v1) 为真               │   │
│  │  EXPECT_PRED2(pred, v1, v2)  │  二元谓词 pred(v1,v2) 为真            │   │
│  │  优势：失败时打印参数值，比 EXPECT_TRUE 信息更丰富                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### EXPECT vs ASSERT 选择决策树

```
                              断言失败时
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
           后续断言有意义吗？          后续断言依赖此结果？
                    │                           │
           ┌───────┴───────┐           ┌───────┴───────┐
           │               │           │               │
           ▼               ▼           ▼               ▼
          是              否          是              否
           │               │           │               │
           ▼               ▼           ▼               ▼
     ┌─────────┐     ┌─────────┐ ┌─────────┐     ┌─────────┐
     │ EXPECT  │     │ ASSERT  │ │ ASSERT  │     │ EXPECT  │
     │ (继续)  │     │ (终止)  │ │ (终止)  │     │ (继续)  │
     └─────────┘     └─────────┘ └─────────┘     └─────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          使用建议                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  使用 ASSERT（致命断言）：                                                   │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ • 前置条件检查：指针非空、容器非空                                   │    │
│  │ • 后续代码依赖此断言：解引用指针前、访问元素前                       │    │
│  │ • 关键初始化步骤：数据库连接、文件打开                               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  使用 EXPECT（非致命断言）：                                                 │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ • 多个独立属性验证：对象的各个字段                                   │    │
│  │ • 收集更多失败信息：一次运行发现多个问题                             │    │
│  │ • 测试的主要断言：大多数情况的默认选择                               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  代码示例：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ TEST(Example, AssertVsExpect) {                                     │    │
│  │     auto* ptr = GetObject();                                        │    │
│  │     ASSERT_NE(ptr, nullptr);  // 必须用ASSERT，后面要解引用         │    │
│  │                                                                     │    │
│  │     EXPECT_EQ(ptr->name, "test");   // 独立验证，用EXPECT           │    │
│  │     EXPECT_GT(ptr->size, 0);        // 即使上面失败也继续           │    │
│  │     EXPECT_TRUE(ptr->is_valid());   // 收集所有失败信息             │    │
│  │ }                                                                   │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

**测试夹具（Test Fixture）**：

```cpp
// ==========================================
// 测试夹具 - 共享测试设置
// ==========================================
class VectorTest : public ::testing::Test {
protected:
    // 每个测试前执行
    void SetUp() override {
        vec_.push_back(1);
        vec_.push_back(2);
        vec_.push_back(3);
    }

    // 每个测试后执行
    void TearDown() override {
        vec_.clear();
    }

    // 可以添加辅助函数
    bool contains(int value) {
        return std::find(vec_.begin(), vec_.end(), value) != vec_.end();
    }

    std::vector<int> vec_;
};

// 使用TEST_F而不是TEST
TEST_F(VectorTest, InitialSize) {
    EXPECT_EQ(vec_.size(), 3);
}

TEST_F(VectorTest, ContainsValue) {
    EXPECT_TRUE(contains(2));
    EXPECT_FALSE(contains(10));
}

TEST_F(VectorTest, PushBackIncreasesSize) {
    vec_.push_back(4);
    EXPECT_EQ(vec_.size(), 4);
}

// ==========================================
// 共享夹具（所有测试共享一次设置）
// ==========================================
class DatabaseTest : public ::testing::Test {
protected:
    // 整个测试套件执行一次
    static void SetUpTestSuite() {
        db_ = std::make_unique<Database>();
        db_->connect("test_db");
    }

    static void TearDownTestSuite() {
        db_->disconnect();
        db_.reset();
    }

    static std::unique_ptr<Database> db_;
};

std::unique_ptr<Database> DatabaseTest::db_;
```

#### 测试夹具生命周期详解

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      测试夹具执行流程                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  TestSuite级别（整个套件执行一次）:                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    SetUpTestSuite()                                  │   │
│  │         （可选）初始化昂贵的共享资源：数据库连接、大文件加载          │   │
│  └─────────────────────────────────┬───────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐  │
│  │                                                                       │  │
│  │   Test 1:  ┌──────────┐    ┌──────────┐    ┌──────────┐              │  │
│  │            │ SetUp()  │───▶│TestBody()│───▶│TearDown()│              │  │
│  │            └──────────┘    └──────────┘    └──────────┘              │  │
│  │                                    │                                  │  │
│  │                                    ▼                                  │  │
│  │   Test 2:  ┌──────────┐    ┌──────────┐    ┌──────────┐              │  │
│  │            │ SetUp()  │───▶│TestBody()│───▶│TearDown()│              │  │
│  │            └──────────┘    └──────────┘    └──────────┘              │  │
│  │                                    │                                  │  │
│  │                                    ▼                                  │  │
│  │   Test N:  ┌──────────┐    ┌──────────┐    ┌──────────┐              │  │
│  │            │ SetUp()  │───▶│TestBody()│───▶│TearDown()│              │  │
│  │            └──────────┘    └──────────┘    └──────────┘              │  │
│  │                                                                       │  │
│  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘  │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                   TearDownTestSuite()                                │   │
│  │              （可选）释放共享资源：断开连接、删除临时文件             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  关键点：                                                                    │
│  • 每个TEST_F创建新的夹具实例（构造函数 → SetUp → Test → TearDown → 析构） │
│  • SetUpTestSuite/TearDownTestSuite 必须是 static 方法                     │
│  • 即使测试失败，TearDown 也会执行（保证资源清理）                          │
│  • 测试之间完全隔离，状态不会相互影响                                       │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### GTest 命令行参数完整参考

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Google Test 命令行参数                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  测试过滤（最常用）:                                                         │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ --gtest_filter=PATTERN      │  只运行匹配的测试                     │    │
│  │                             │  通配符: * 任意字符, ? 单字符         │    │
│  │                             │  示例: "Vector*" "*.Push*" "*Test"   │    │
│  │ --gtest_filter=-PATTERN     │  排除匹配的测试（负向过滤）           │    │
│  │ --gtest_filter=A:B:-C       │  运行A和B，排除C                      │    │
│  │                             │  示例: "*Slow*:-*VeryS*"             │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  执行控制:                                                                   │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ --gtest_repeat=N            │  重复运行测试N次（-1=无限）           │    │
│  │ --gtest_shuffle             │  随机打乱测试顺序                     │    │
│  │ --gtest_random_seed=N       │  设置随机种子（配合shuffle）          │    │
│  │ --gtest_break_on_failure    │  失败时触发调试器断点                 │    │
│  │ --gtest_catch_exceptions=0  │  不捕获异常（方便调试）               │    │
│  │ --gtest_also_run_disabled   │  也运行DISABLED_前缀的测试            │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  输出控制:                                                                   │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ --gtest_output=xml[:FILE]   │  输出XML格式报告（CI集成）            │    │
│  │ --gtest_output=json[:FILE]  │  输出JSON格式报告                     │    │
│  │ --gtest_color=yes/no/auto   │  彩色输出控制                         │    │
│  │ --gtest_print_time=0        │  不打印测试耗时                       │    │
│  │ --gtest_brief=1             │  简洁输出（只显示失败）               │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  列出测试（不执行）:                                                         │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ --gtest_list_tests          │  列出所有测试名称                     │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  常用命令示例:                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ # 只运行Vector相关测试                                              │    │
│  │ ./tests --gtest_filter="VectorTest.*"                              │    │
│  │                                                                     │    │
│  │ # 随机顺序运行10次，发现顺序依赖                                    │    │
│  │ ./tests --gtest_shuffle --gtest_repeat=10                          │    │
│  │                                                                     │    │
│  │ # 生成CI报告                                                        │    │
│  │ ./tests --gtest_output=xml:report.xml                              │    │
│  │                                                                     │    │
│  │ # 调试模式：失败时断点，不捕获异常                                  │    │
│  │ ./tests --gtest_break_on_failure --gtest_catch_exceptions=0        │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 1 输出物清单

| 类别 | 文件/目录 | 说明 |
|------|-----------|------|
| 项目模板 | `gtest_basics/CMakeLists.txt` | GTest + CMake 集成配置 |
| 项目模板 | `gtest_basics/vcpkg.json` | 依赖声明 |
| 断言示例 | `gtest_basics/test_assertions.cpp` | 六类断言完整示例 |
| 夹具示例 | `gtest_basics/test_fixtures.cpp` | SetUp/TearDown 各种模式 |
| 运行脚本 | `gtest_basics/run_tests.sh` | 常用过滤和输出参数 |
| 学习笔记 | `notes/week1_gtest_basics.md` | 核心概念总结 |

#### Week 1 检验标准

- [ ] 能独立配置GTest + CMake项目
- [ ] 理解TEST和TEST_F的区别
- [ ] 能正确选择EXPECT和ASSERT
- [ ] 掌握六类断言的使用场景
- [ ] 能编写SetUp/TearDown管理资源
- [ ] 能使用命令行参数过滤和调试测试

---

### 第二周：参数化测试与类型测试

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Week 2: 参数化测试与类型测试                              │
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Day 8-9    │───▶│  Day 10-11  │───▶│  Day 12-13  │───▶│   Day 14    │  │
│  │ 值参数化    │    │ 生成器深入  │    │ 类型参数化  │    │ 综合实践    │  │
│  │ 测试基础    │    │ 组合策略    │    │ 测试技术    │    │ 最佳实践    │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│                                                                             │
│  核心技能：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ • TestWithParam模板使用              • Values/Range/Combine生成器      │ │
│  │ • INSTANTIATE_TEST_SUITE_P宏        • TYPED_TEST模板类测试             │ │
│  │ • 测试数据外部化管理                 • 测试命名策略                     │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  输出物：parameterized_tests/项目 + 笔记                   学习时间：35小时 │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 2 每日任务分解

| 天数 | 时间 | 主题 | 具体任务 | 输出物 |
|------|------|------|----------|--------|
| Day 8 | 5h | 值参数化基础 | 1. TestWithParam模板 2. GetParam()获取参数 3. Values()生成器 4. 自定义输出格式 | 基础参数化示例 |
| Day 9 | 5h | 参数化命名 | 1. INSTANTIATE_TEST_SUITE_P 2. 自定义测试名称生成器 3. 参数打印优化 | 命名策略示例 |
| Day 10 | 5h | 生成器详解 | 1. Range()数值范围 2. ValuesIn()外部数据 3. Bool()布尔组合 4. 生成器对比 | 生成器示例库 |
| Day 11 | 5h | 组合测试 | 1. Combine()笛卡尔积 2. tuple参数解包 3. 测试用例爆炸问题 4. 合理控制组合 | 组合测试示例 |
| Day 12 | 5h | 类型测试基础 | 1. TYPED_TEST_SUITE 2. 类型列表定义 3. 模板测试编写 4. 容器接口测试 | 类型测试示例 |
| Day 13 | 5h | 高级类型测试 | 1. TYPED_TEST_SUITE_P 2. REGISTER_TYPED_TEST_SUITE_P 3. 运行时类型注册 | 高级类型测试 |
| Day 14 | 5h | 综合与最佳实践 | 1. 测试数据外部化 2. 测试过滤策略 3. 性能考虑 4. Week 2总结 | 最佳实践文档 |

---

**学习目标**：掌握高级测试技术

**阅读材料**：
- [ ] GTest: Advanced Guide
- [ ] 参数化测试最佳实践

```cpp
// ==========================================
// 值参数化测试
// ==========================================
class PrimeTest : public ::testing::TestWithParam<int> {};

TEST_P(PrimeTest, IsPrime) {
    int n = GetParam();
    EXPECT_TRUE(is_prime(n)) << n << " should be prime";
}

// 单个值列表
INSTANTIATE_TEST_SUITE_P(
    PrimeNumbers,
    PrimeTest,
    ::testing::Values(2, 3, 5, 7, 11, 13)
);

// 范围
INSTANTIATE_TEST_SUITE_P(
    Range,
    PrimeTest,
    ::testing::Range(2, 10)  // 2到9
);

// 组合
class MultiplicationTest : public ::testing::TestWithParam<std::tuple<int, int, int>> {};

TEST_P(MultiplicationTest, Multiply) {
    auto [a, b, expected] = GetParam();
    EXPECT_EQ(a * b, expected);
}

INSTANTIATE_TEST_SUITE_P(
    MulTable,
    MultiplicationTest,
    ::testing::Values(
        std::make_tuple(1, 1, 1),
        std::make_tuple(2, 3, 6),
        std::make_tuple(4, 5, 20)
    )
);

// 笛卡尔积
INSTANTIATE_TEST_SUITE_P(
    CartesianProduct,
    SomeTest,
    ::testing::Combine(
        ::testing::Values(1, 2, 3),
        ::testing::Values("a", "b"),
        ::testing::Bool()
    )
);
```

#### 参数化测试原理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      参数化测试工作原理                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  传统方式（代码重复）:                   参数化方式（数据驱动）:              │
│  ┌───────────────────────┐              ┌───────────────────────┐          │
│  │ TEST(IsPrime, Two) {  │              │ TEST_P(PrimeTest, X) {│          │
│  │   EXPECT_TRUE(        │              │   int n = GetParam(); │          │
│  │     is_prime(2));     │              │   EXPECT_TRUE(        │          │
│  │ }                     │              │     is_prime(n));     │          │
│  │ TEST(IsPrime, Three) {│              │ }                     │          │
│  │   EXPECT_TRUE(        │              │                       │          │
│  │     is_prime(3));     │              │ INSTANTIATE...(       │          │
│  │ }                     │              │   PrimeNumbers,       │          │
│  │ TEST(IsPrime, Five) { │              │   PrimeTest,          │          │
│  │   EXPECT_TRUE(        │              │   Values(2,3,5,7,11)  │          │
│  │     is_prime(5));     │              │ );                    │          │
│  │ }                     │              └───────────────────────┘          │
│  │ // ... 更多重复       │                                                 │
│  └───────────────────────┘                                                 │
│                                                                             │
│  参数化测试执行流程:                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │    Generator         Parameter        Test Instance                 │   │
│  │  ┌──────────┐      ┌──────────┐      ┌────────────────────┐        │   │
│  │  │ Values(  │ ───▶ │  param1  │ ───▶ │ PrimeTest/Prime/0  │        │   │
│  │  │ 2,3,5,7) │      ├──────────┤      ├────────────────────┤        │   │
│  │  └──────────┘      │  param2  │ ───▶ │ PrimeTest/Prime/1  │        │   │
│  │                    ├──────────┤      ├────────────────────┤        │   │
│  │                    │  param3  │ ───▶ │ PrimeTest/Prime/2  │        │   │
│  │                    ├──────────┤      ├────────────────────┤        │   │
│  │                    │  param4  │ ───▶ │ PrimeTest/Prime/3  │        │   │
│  │                    └──────────┘      └────────────────────┘        │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  优势:                                                                       │
│  • 减少代码重复，DRY原则                                                     │
│  • 易于添加新测试用例（只需添加数据）                                        │
│  • 测试数据可外部化（从文件/数据库加载）                                     │
│  • 每个参数组合独立报告结果                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 参数生成器对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        GTest 参数生成器                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┬───────────────────────────────────────────────────────┐   │
│  │ 生成器       │ 说明与示例                                            │   │
│  ├─────────────┼───────────────────────────────────────────────────────┤   │
│  │ Values()    │ 枚举具体值                                             │   │
│  │             │ Values(1, 2, 3, 5, 8, 13)                             │   │
│  │             │ Values("GET", "POST", "PUT", "DELETE")                │   │
│  │             │ 适用：有限的离散值集合                                 │   │
│  ├─────────────┼───────────────────────────────────────────────────────┤   │
│  │ Range()     │ 数值范围 [begin, end, step=1)                          │   │
│  │             │ Range(0, 100)      // 0-99                            │   │
│  │             │ Range(0, 100, 10)  // 0,10,20,...,90                  │   │
│  │             │ 适用：连续数值范围、边界测试                           │   │
│  ├─────────────┼───────────────────────────────────────────────────────┤   │
│  │ ValuesIn()  │ 从容器或迭代器范围获取                                 │   │
│  │             │ std::vector<int> data = {1, 2, 3};                    │   │
│  │             │ ValuesIn(data)                                        │   │
│  │             │ ValuesIn(data.begin(), data.end())                    │   │
│  │             │ 适用：外部数据源、动态生成的测试数据                   │   │
│  ├─────────────┼───────────────────────────────────────────────────────┤   │
│  │ Bool()      │ 布尔值组合                                             │   │
│  │             │ Bool()  // true, false                                │   │
│  │             │ 适用：开关参数、条件组合                               │   │
│  ├─────────────┼───────────────────────────────────────────────────────┤   │
│  │ Combine()   │ 多参数笛卡尔积                                         │   │
│  │             │ Combine(                                              │   │
│  │             │   Values(1, 2),        // 2个值                       │   │
│  │             │   Values("a", "b"),    // 2个值                       │   │
│  │             │   Bool()               // 2个值                       │   │
│  │             │ )  // 产生 2×2×2 = 8 个测试                           │   │
│  │             │ ⚠️ 注意组合爆炸：5×5×5×5 = 625 个测试！               │   │
│  └─────────────┴───────────────────────────────────────────────────────┘   │
│                                                                             │
│  自定义测试命名:                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ // 默认命名: TestSuite/Prefix/0, TestSuite/Prefix/1, ...           │    │
│  │ // 自定义命名器:                                                    │    │
│  │ class NameGenerator {                                               │    │
│  │ public:                                                             │    │
│  │     std::string operator()(                                         │    │
│  │         const ::testing::TestParamInfo<int>& info) const {          │    │
│  │         return "Value_" + std::to_string(info.param);               │    │
│  │     }                                                               │    │
│  │ };                                                                  │    │
│  │                                                                     │    │
│  │ INSTANTIATE_TEST_SUITE_P(                                          │    │
│  │     Primes, PrimeTest,                                             │    │
│  │     Values(2, 3, 5, 7),                                            │    │
│  │     NameGenerator()  // 产生: PrimeTest.Primes/Value_2 等          │    │
│  │ );                                                                 │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

```cpp

// ==========================================
// 类型参数化测试
// ==========================================
template <typename T>
class ContainerTest : public ::testing::Test {
protected:
    T container_;
};

using ContainerTypes = ::testing::Types<
    std::vector<int>,
    std::list<int>,
    std::deque<int>
>;

TYPED_TEST_SUITE(ContainerTest, ContainerTypes);

TYPED_TEST(ContainerTest, EmptyOnConstruction) {
    EXPECT_TRUE(this->container_.empty());
}

TYPED_TEST(ContainerTest, SizeAfterPushBack) {
    this->container_.push_back(1);
    EXPECT_EQ(this->container_.size(), 1);
}

// ==========================================
// 运行时类型参数化
// ==========================================
template <typename T>
class TypedContainerTest : public ::testing::Test {};

TYPED_TEST_SUITE_P(TypedContainerTest);

TYPED_TEST_P(TypedContainerTest, Empty) {
    TypeParam container;
    EXPECT_TRUE(container.empty());
}

TYPED_TEST_P(TypedContainerTest, Size) {
    TypeParam container;
    container.push_back(typename TypeParam::value_type{});
    EXPECT_EQ(container.size(), 1);
}

REGISTER_TYPED_TEST_SUITE_P(TypedContainerTest, Empty, Size);

using MyTypes = ::testing::Types<std::vector<int>, std::vector<double>>;
INSTANTIATE_TYPED_TEST_SUITE_P(My, TypedContainerTest, MyTypes);
```

#### TYPED_TEST vs TYPED_TEST_P 对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   类型测试两种模式对比                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────────────────────────┬──────────────────────────────────┐   │
│  │       TYPED_TEST (编译时)        │    TYPED_TEST_P (可复用)         │   │
│  ├──────────────────────────────────┼──────────────────────────────────┤   │
│  │ 类型列表在定义处指定              │ 类型列表在实例化处指定            │   │
│  │                                  │                                  │   │
│  │ template <typename T>            │ template <typename T>            │   │
│  │ class FooTest : Test {};         │ class BarTest : Test {};         │   │
│  │                                  │                                  │   │
│  │ using Types = Types<int,float>;  │ TYPED_TEST_SUITE_P(BarTest);    │   │
│  │ TYPED_TEST_SUITE(FooTest,Types); │                                  │   │
│  │                                  │ TYPED_TEST_P(BarTest, DoX) {...} │   │
│  │ TYPED_TEST(FooTest, DoX) {...}   │ TYPED_TEST_P(BarTest, DoY) {...} │   │
│  │                                  │                                  │   │
│  │                                  │ REGISTER_TYPED_TEST_SUITE_P(     │   │
│  │                                  │   BarTest, DoX, DoY);            │   │
│  │                                  │                                  │   │
│  │                                  │ // 可多次实例化，使用不同类型     │   │
│  │                                  │ INSTANTIATE_TYPED_TEST_SUITE_P(  │   │
│  │                                  │   Int, BarTest, Types<int>);     │   │
│  │                                  │ INSTANTIATE_TYPED_TEST_SUITE_P(  │   │
│  │                                  │   Float, BarTest, Types<float>); │   │
│  ├──────────────────────────────────┼──────────────────────────────────┤   │
│  │ 适用场景：                        │ 适用场景：                        │   │
│  │ • 类型列表固定不变                │ • 测试模板供多处复用              │   │
│  │ • 单个测试文件使用                │ • 跨项目/库共享测试              │   │
│  │ • 简单直接                        │ • 类型列表需要灵活配置            │   │
│  └──────────────────────────────────┴──────────────────────────────────┘   │
│                                                                             │
│  类型测试使用场景：                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ • 模板类/函数测试：确保对所有支持类型行为一致                        │    │
│  │ • 容器接口测试：vector/list/deque 应满足相同的接口契约              │    │
│  │ • 数值类型测试：int/float/double 的数学运算                         │    │
│  │ • 跨平台类型测试：int32_t/int64_t 在不同平台的行为                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 测试数据管理最佳实践

```cpp
// ==========================================
// 从外部文件加载测试数据
// ==========================================
#include <fstream>
#include <sstream>

// 测试数据结构
struct TestCase {
    std::string input;
    std::string expected;
    std::string description;
};

// 从CSV加载测试用例
std::vector<TestCase> LoadTestCases(const std::string& filename) {
    std::vector<TestCase> cases;
    std::ifstream file(filename);
    std::string line;

    while (std::getline(file, line)) {
        if (line.empty() || line[0] == '#') continue;  // 跳过空行和注释

        std::istringstream iss(line);
        TestCase tc;
        std::getline(iss, tc.input, ',');
        std::getline(iss, tc.expected, ',');
        std::getline(iss, tc.description, ',');
        cases.push_back(tc);
    }
    return cases;
}

// 参数化测试使用外部数据
class FileBasedTest : public ::testing::TestWithParam<TestCase> {};

TEST_P(FileBasedTest, ProcessInput) {
    auto tc = GetParam();
    EXPECT_EQ(Process(tc.input), tc.expected) << tc.description;
}

// 从文件加载测试用例
INSTANTIATE_TEST_SUITE_P(
    FromFile,
    FileBasedTest,
    ::testing::ValuesIn(LoadTestCases("test_data.csv")),
    [](const auto& info) {
        // 使用description作为测试名
        return info.param.description;
    }
);
```

#### Week 2 输出物清单

| 类别 | 文件/目录 | 说明 |
|------|-----------|------|
| 参数化示例 | `parameterized/test_values.cpp` | Values/Range/ValuesIn示例 |
| 组合测试 | `parameterized/test_combine.cpp` | Combine笛卡尔积示例 |
| 类型测试 | `parameterized/test_typed.cpp` | TYPED_TEST系列示例 |
| 数据驱动 | `parameterized/test_data.csv` | 外部测试数据文件 |
| 数据加载 | `parameterized/test_file_based.cpp` | 从文件加载测试用例 |
| 学习笔记 | `notes/week2_parameterized.md` | 参数化测试总结 |

#### Week 2 检验标准

- [ ] 能使用TestWithParam编写值参数化测试
- [ ] 熟练使用Values/Range/ValuesIn/Combine生成器
- [ ] 理解组合爆炸问题并能合理控制
- [ ] 能使用TYPED_TEST测试模板类
- [ ] 理解TYPED_TEST_P的复用场景
- [ ] 能实现外部数据驱动的测试

---

### 第三周：Catch2框架

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Week 3: Catch2框架                                        │
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Day 15-16  │───▶│  Day 17-18  │───▶│  Day 19-20  │───▶│   Day 21    │  │
│  │ Catch2基础  │    │ Matcher与   │    │ BDD风格与   │    │ v3新特性    │  │
│  │ SECTION机制 │    │ Generator   │    │ 高级技巧    │    │ 综合对比    │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│                                                                             │
│  核心技能：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ • SECTION嵌套与执行原理             • 内置Matcher与自定义Matcher       │ │
│  │ • SCENARIO/GIVEN/WHEN/THEN风格     • Generator数据生成                 │ │
│  │ • Catch2 vs GTest选型决策           • Header-only快速集成              │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  输出物：catch2_tests/项目 + 笔记                          学习时间：35小时 │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 3 每日任务分解

| 天数 | 时间 | 主题 | 具体任务 | 输出物 |
|------|------|------|----------|--------|
| Day 15 | 5h | Catch2环境与基础 | 1. vcpkg安装Catch2 v3 2. CMake集成 3. TEST_CASE基础 4. REQUIRE/CHECK断言 | Catch2项目模板 |
| Day 16 | 5h | SECTION机制 | 1. SECTION嵌套原理 2. 执行路径分析 3. 状态隔离验证 4. 与Fixture对比 | SECTION示例集 |
| Day 17 | 5h | 内置Matcher | 1. 字符串Matcher 2. 容器Matcher 3. 浮点Matcher 4. 异常Matcher | Matcher示例库 |
| Day 18 | 5h | Generator系统 | 1. GENERATE宏 2. range/filter/map 3. take/random 4. 与GTest参数化对比 | Generator示例 |
| Day 19 | 5h | BDD风格测试 | 1. SCENARIO/GIVEN/WHEN/THEN 2. 用户故事映射 3. 需求追踪 4. 可读性优化 | BDD测试示例 |
| Day 20 | 5h | 高级技巧 | 1. 自定义Matcher编写 2. 测试事件监听 3. 自定义main 4. 与CI集成 | 高级特性示例 |
| Day 21 | 5h | v3新特性与总结 | 1. Catch2 v3变化 2. GTest全面对比 3. 选型决策树 4. Week 3总结 | 对比文档+笔记 |

---

**学习目标**：掌握Catch2的特色功能

**阅读材料**：
- [ ] Catch2官方文档
- [ ] Catch2 vs Google Test对比

```cpp
// ==========================================
// Catch2基础
// ==========================================
#define CATCH_CONFIG_MAIN
#include <catch2/catch_test_macros.hpp>
#include <catch2/catch_approx.hpp>
#include <catch2/matchers/catch_matchers_string.hpp>
#include <catch2/generators/catch_generators.hpp>

// 基本测试（BDD风格）
TEST_CASE("Vector operations", "[vector]") {
    std::vector<int> v;

    SECTION("empty on construction") {
        REQUIRE(v.empty());
        REQUIRE(v.size() == 0);
    }

    SECTION("push_back increases size") {
        v.push_back(1);
        REQUIRE(v.size() == 1);

        SECTION("push_back again") {
            v.push_back(2);
            REQUIRE(v.size() == 2);
        }
    }

    SECTION("clear empties the vector") {
        v.push_back(1);
        v.push_back(2);
        v.clear();
        REQUIRE(v.empty());
    }
}

// ==========================================
// Catch2断言
// ==========================================

// 基本断言
REQUIRE(expr);      // 失败时终止
CHECK(expr);        // 失败时继续

// 比较
REQUIRE(a == b);
REQUIRE(a != b);
REQUIRE(a < b);

// 浮点数
REQUIRE(value == Catch::Approx(3.14).epsilon(0.01));
REQUIRE(value == Catch::Approx(3.14).margin(0.001));

// 异常
REQUIRE_THROWS(expression);
REQUIRE_THROWS_AS(expression, ExceptionType);
REQUIRE_THROWS_WITH(expression, "message");
REQUIRE_NOTHROW(expression);

// Matcher风格
using namespace Catch::Matchers;

REQUIRE_THAT(str, StartsWith("Hello"));
REQUIRE_THAT(str, EndsWith("World"));
REQUIRE_THAT(str, ContainsSubstring("middle"));
REQUIRE_THAT(str, Matches("H.*d"));  // 正则

REQUIRE_THAT(vec, Contains(42));
REQUIRE_THAT(vec, VectorContains(42));
REQUIRE_THAT(vec, IsEmpty());
REQUIRE_THAT(vec, SizeIs(3));
```

#### Google Test vs Catch2 全面对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Google Test vs Catch2 对比                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┬───────────────────────┬───────────────────────┐       │
│  │     特性         │    Google Test        │      Catch2           │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 集成方式         │ 编译库 + 链接          │ Header-only (v2)      │       │
│  │                 │                       │ 编译库 (v3)           │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 测试组织         │ TEST_F + SetUp/Down   │ SECTION 嵌套          │       │
│  │                 │ 显式的夹具类           │ 隐式状态管理          │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 断言风格         │ EXPECT_* / ASSERT_*   │ REQUIRE / CHECK       │       │
│  │                 │ 宏风格                 │ 表达式风格            │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 参数化测试       │ TestWithParam         │ GENERATE宏            │       │
│  │                 │ 需要专门的类           │ 更简洁的语法          │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ Mock支持         │ GMock（原生集成）     │ 需配合第三方          │       │
│  │                 │                       │ (trompeloeil等)       │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ BDD风格          │ 不直接支持            │ SCENARIO/GIVEN/WHEN   │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 类型测试         │ TYPED_TEST系列        │ TEMPLATE_TEST_CASE    │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 编译时间         │ 较快（预编译）        │ v2较慢/v3改善         │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 企业采用         │ 广泛（Google背书）    │ 中等                  │       │
│  ├─────────────────┼───────────────────────┼───────────────────────┤       │
│  │ 学习曲线         │ 中等                  │ 较低                  │       │
│  └─────────────────┴───────────────────────┴───────────────────────┘       │
│                                                                             │
│  选型建议：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 选择 Google Test 当：                                               │    │
│  │   • 需要强大的Mock功能（GMock）                                     │    │
│  │   • 大型项目，编译时间敏感                                          │    │
│  │   • 团队有GTest经验                                                 │    │
│  │   • 需要企业级支持和文档                                            │    │
│  ├────────────────────────────────────────────────────────────────────┤    │
│  │ 选择 Catch2 当：                                                    │    │
│  │   • 偏好BDD风格测试                                                 │    │
│  │   • 小型项目，快速原型                                              │    │
│  │   • 喜欢SECTION的组织方式                                           │    │
│  │   • 需要更简洁的语法                                                │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### SECTION 嵌套执行原理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      SECTION 执行原理                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  代码结构：                            执行路径：                            │
│  ┌────────────────────────────┐       ┌────────────────────────────┐       │
│  │ TEST_CASE("Vector") {      │       │                            │       │
│  │   vector<int> v;           │       │  第1次运行：               │       │
│  │   // 共享初始化代码         │       │  init → A                  │       │
│  │                            │       │                            │       │
│  │   SECTION("A") {           │       │  第2次运行：               │       │
│  │     // 路径A               │       │  init → B → B1             │       │
│  │   }                        │       │                            │       │
│  │                            │       │  第3次运行：               │       │
│  │   SECTION("B") {           │       │  init → B → B2             │       │
│  │     // 路径B共享           │       │                            │       │
│  │                            │       │  第4次运行：               │       │
│  │     SECTION("B1") {        │       │  init → C                  │       │
│  │       // 路径B1            │       │                            │       │
│  │     }                      │       │  总计：4次独立执行         │       │
│  │     SECTION("B2") {        │       │  每次都从头开始            │       │
│  │       // 路径B2            │       │  状态完全隔离              │       │
│  │     }                      │       │                            │       │
│  │   }                        │       └────────────────────────────┘       │
│  │                            │                                            │
│  │   SECTION("C") {           │       执行树可视化：                        │
│  │     // 路径C               │       ┌─────────────────────────┐          │
│  │   }                        │       │      TEST_CASE          │          │
│  │ }                          │       │         │               │          │
│  └────────────────────────────┘       │    ┌────┼────┬────┐     │          │
│                                       │    ▼    ▼    │    ▼     │          │
│  与GTest Fixture对比：                 │   [A]  [B]   │   [C]    │          │
│  ┌────────────────────────────┐       │        │     │          │          │
│  │ GTest: 每个TEST_F独立创建  │       │    ┌───┴───┐ │          │          │
│  │        夹具实例            │       │    ▼       ▼ │          │          │
│  │                            │       │  [B1]    [B2]│          │          │
│  │ Catch2: 同一TEST_CASE多次  │       └─────────────────────────┘          │
│  │         执行,每次走不同路径│                                            │
│  └────────────────────────────┘                                            │
│                                                                             │
│  SECTION优势：                                                               │
│  • 共享初始化代码，减少重复                                                  │
│  • 更清晰的逻辑分组                                                         │
│  • 易于添加新的测试分支                                                      │
│  • 自然表达"给定X，当Y时..."的测试思路                                       │
└─────────────────────────────────────────────────────────────────────────────┘
```

```cpp
// ==========================================
// Catch2生成器（数据驱动测试）
// ==========================================
TEST_CASE("Generators", "[generators]") {
    // 简单生成器
    auto i = GENERATE(1, 2, 3, 4, 5);
    REQUIRE(i > 0);

    // 范围生成器
    auto j = GENERATE(range(1, 10));
    REQUIRE(j >= 1);
    REQUIRE(j < 10);

    // 过滤器
    auto even = GENERATE(filter([](int n) { return n % 2 == 0; }, range(1, 100)));
    REQUIRE(even % 2 == 0);

    // 映射
    auto squared = GENERATE(map([](int n) { return n * n; }, range(1, 5)));

    // 组合
    auto a = GENERATE(1, 2, 3);
    auto b = GENERATE(10, 20);
    CAPTURE(a, b);  // 打印当前值
    REQUIRE(a + b > 0);

    // 随机生成
    auto random = GENERATE(take(100, random(1, 1000)));
    REQUIRE(random >= 1);
    REQUIRE(random <= 1000);
}
```

#### Matcher系统架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Catch2 Matcher系统                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  内置Matcher分类：                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  字符串Matcher:                                                      │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ StartsWith("prefix")     │ 以指定前缀开始                   │    │   │
│  │  │ EndsWith("suffix")       │ 以指定后缀结束                   │    │   │
│  │  │ ContainsSubstring("sub") │ 包含子串                         │    │   │
│  │  │ Matches("regex")         │ 正则匹配                         │    │   │
│  │  │ Equals("str", CaseSense) │ 相等（可选大小写敏感）           │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  │  容器Matcher:                                                        │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ Contains(elem)           │ 包含元素                         │    │   │
│  │  │ VectorContains(elem)     │ 专用于vector                     │    │   │
│  │  │ Contains(matcher)        │ 包含匹配元素                     │    │   │
│  │  │ IsEmpty()                │ 为空                             │    │   │
│  │  │ SizeIs(n)                │ 大小为n                          │    │   │
│  │  │ SizeIs(matcher)          │ 大小满足条件                     │    │   │
│  │  │ Equals(container)        │ 元素完全相等                     │    │   │
│  │  │ UnorderedEquals(cont)    │ 元素相等（忽略顺序）             │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  │  浮点Matcher:                                                        │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ WithinAbs(target, margin)│ 绝对误差范围                     │    │   │
│  │  │ WithinRel(target, eps)   │ 相对误差范围                     │    │   │
│  │  │ WithinULP(target, ulps)  │ ULP单位误差                      │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  │  组合Matcher:                                                        │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ !matcher                 │ 逻辑非                           │    │   │
│  │  │ matcher1 && matcher2     │ 逻辑与                           │    │   │
│  │  │ matcher1 || matcher2     │ 逻辑或                           │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  自定义Matcher示例：                                                         │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ // 检查是否为偶数的Matcher                                          │    │
│  │ struct IsEvenMatcher : Catch::Matchers::MatcherBase<int> {          │    │
│  │     bool match(int n) const override {                              │    │
│  │         return n % 2 == 0;                                          │    │
│  │     }                                                               │    │
│  │     std::string describe() const override {                         │    │
│  │         return "is even";                                           │    │
│  │     }                                                               │    │
│  │ };                                                                  │    │
│  │                                                                     │    │
│  │ // 使用自定义Matcher                                                │    │
│  │ TEST_CASE("Custom matcher") {                                       │    │
│  │     REQUIRE_THAT(4, IsEvenMatcher{});                               │    │
│  │     REQUIRE_THAT(3, !IsEvenMatcher{});                              │    │
│  │ }                                                                   │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

```cpp

// ==========================================
// BDD风格测试
// ==========================================
SCENARIO("Bank account operations", "[account]") {
    GIVEN("A bank account with initial balance") {
        BankAccount account(1000);

        WHEN("Depositing money") {
            account.deposit(500);

            THEN("Balance increases") {
                REQUIRE(account.balance() == 1500);
            }
        }

        WHEN("Withdrawing money") {
            bool result = account.withdraw(300);

            THEN("Withdrawal succeeds") {
                REQUIRE(result);
                REQUIRE(account.balance() == 700);
            }
        }

        WHEN("Withdrawing more than balance") {
            bool result = account.withdraw(2000);

            THEN("Withdrawal fails") {
                REQUIRE_FALSE(result);
                REQUIRE(account.balance() == 1000);
            }
        }
    }
}

// ==========================================
// Catch2测试夹具
// ==========================================
class DatabaseFixture {
protected:
    Database db;

public:
    DatabaseFixture() {
        db.connect("test_db");
    }

    ~DatabaseFixture() {
        db.disconnect();
    }
};

TEST_CASE_METHOD(DatabaseFixture, "Database operations", "[database]") {
    SECTION("Insert and retrieve") {
        db.insert("key", "value");
        REQUIRE(db.get("key") == "value");
    }

    SECTION("Delete") {
        db.insert("key", "value");
        db.remove("key");
        REQUIRE_FALSE(db.exists("key"));
    }
}
```

#### BDD测试设计最佳实践

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      BDD测试设计模式                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  用户故事到测试的映射：                                                       │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  用户故事：                                                          │   │
│  │  "作为一个用户，我希望能够登录系统，以便访问我的个人数据"              │   │
│  │                                                                     │   │
│  │                           ↓ 转换为                                   │   │
│  │                                                                     │   │
│  │  SCENARIO("User login", "[auth]") {                                │   │
│  │      GIVEN("A registered user") {                                   │   │
│  │          User user = createTestUser();                              │   │
│  │          registerUser(user);                                        │   │
│  │                                                                     │   │
│  │          WHEN("User provides correct credentials") {                │   │
│  │              auto result = login(user.email, user.password);        │   │
│  │                                                                     │   │
│  │              THEN("Login succeeds") {                               │   │
│  │                  REQUIRE(result.success);                           │   │
│  │                  REQUIRE(result.token.length() > 0);                │   │
│  │              }                                                      │   │
│  │          }                                                          │   │
│  │                                                                     │   │
│  │          WHEN("User provides wrong password") {                     │   │
│  │              auto result = login(user.email, "wrong");              │   │
│  │                                                                     │   │
│  │              THEN("Login fails with error") {                       │   │
│  │                  REQUIRE_FALSE(result.success);                     │   │
│  │                  REQUIRE(result.error == "Invalid credentials");    │   │
│  │              }                                                      │   │
│  │          }                                                          │   │
│  │      }                                                              │   │
│  │  }                                                                  │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  BDD命名规范：                                                               │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ SCENARIO   │ 描述功能或用户故事                                     │    │
│  │ GIVEN      │ 前置条件（系统初始状态）                               │    │
│  │ WHEN       │ 触发动作（用户行为或事件）                             │    │
│  │ THEN       │ 期望结果（可观察的输出或状态变化）                     │    │
│  │ AND        │ 附加条件（可在GIVEN/WHEN/THEN后使用）                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  与需求追踪：                                                                │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ // 使用标签关联需求                                                 │    │
│  │ SCENARIO("REQ-001: User registration",                             │    │
│  │          "[auth][registration][REQ-001]") {                        │    │
│  │     // ...                                                          │    │
│  │ }                                                                  │    │
│  │                                                                     │    │
│  │ // 运行特定需求的所有测试                                           │    │
│  │ // ./tests "[REQ-001]"                                             │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Catch2 v3 新特性

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      Catch2 v3 重要变化                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  架构变化：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ • 从 Header-only 改为 编译库                                        │    │
│  │ • 大幅改善编译时间（尤其大型项目）                                  │    │
│  │ • 需要 C++14 或更高版本                                             │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  头文件变化：                                                                │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ // v2:                                                              │    │
│  │ #define CATCH_CONFIG_MAIN                                          │    │
│  │ #include <catch2/catch.hpp>                                        │    │
│  │                                                                     │    │
│  │ // v3: 分模块头文件                                                 │    │
│  │ #include <catch2/catch_test_macros.hpp>                            │    │
│  │ #include <catch2/catch_approx.hpp>                                 │    │
│  │ #include <catch2/matchers/catch_matchers_string.hpp>               │    │
│  │ #include <catch2/generators/catch_generators.hpp>                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  CMake集成变化：                                                             │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ # v3 使用独立的 main 库                                             │    │
│  │ find_package(Catch2 3 REQUIRED)                                    │    │
│  │                                                                     │    │
│  │ add_executable(tests test.cpp)                                     │    │
│  │ target_link_libraries(tests                                        │    │
│  │     PRIVATE Catch2::Catch2WithMain  # 包含main函数                 │    │
│  │ )                                                                  │    │
│  │                                                                     │    │
│  │ # 或自定义main                                                      │    │
│  │ target_link_libraries(tests                                        │    │
│  │     PRIVATE Catch2::Catch2          # 不包含main                   │    │
│  │ )                                                                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  新增特性：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ • STATIC_REQUIRE: 编译期静态断言                                    │    │
│  │ • 改进的基准测试(Benchmark)支持                                     │    │
│  │ • 更好的并行测试支持                                                │    │
│  │ • 改进的XML/JUnit报告格式                                           │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 3 输出物清单

| 类别 | 文件/目录 | 说明 |
|------|-----------|------|
| 项目模板 | `catch2_tests/CMakeLists.txt` | Catch2 v3 + CMake配置 |
| SECTION示例 | `catch2_tests/test_sections.cpp` | SECTION嵌套与执行路径 |
| Matcher示例 | `catch2_tests/test_matchers.cpp` | 内置与自定义Matcher |
| Generator示例 | `catch2_tests/test_generators.cpp` | 数据生成与组合 |
| BDD示例 | `catch2_tests/test_bdd.cpp` | SCENARIO风格测试 |
| 学习笔记 | `notes/week3_catch2.md` | Catch2核心概念 |
| 对比文档 | `notes/gtest_vs_catch2.md` | 选型决策参考 |

#### Week 3 检验标准

- [ ] 能配置Catch2 v3项目
- [ ] 理解SECTION嵌套执行原理
- [ ] 能使用和组合内置Matcher
- [ ] 能编写自定义Matcher
- [ ] 能使用GENERATE进行数据驱动测试
- [ ] 能编写BDD风格的测试
- [ ] 能根据场景选择GTest或Catch2

---

### 第四周：Mock对象与测试设计

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Week 4: Mock对象与测试设计                                │
│                                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Day 22-23  │───▶│  Day 24-25  │───▶│  Day 26-27  │───▶│   Day 28    │  │
│  │ GMock基础   │    │ 测试替身    │    │ TDD实践与   │    │ 覆盖率与    │  │
│  │ 与高级用法  │    │ 模式详解    │    │ 可测试设计  │    │ 月度总结    │  │
│  └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘  │
│                                                                             │
│  核心技能：                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ • MOCK_METHOD与EXPECT_CALL              • Mock/Stub/Fake/Spy区别      │ │
│  │ • 参数匹配器与返回值控制                 • 依赖注入与可测试性设计      │ │
│  │ • TDD红绿重构循环                        • gcov/lcov覆盖率工具         │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  输出物：mock_tests/ + TDD项目 + 覆盖率报告                学习时间：35小时 │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 4 每日任务分解

| 天数 | 时间 | 主题 | 具体任务 | 输出物 |
|------|------|------|----------|--------|
| Day 22 | 5h | GMock基础 | 1. MOCK_METHOD宏 2. EXPECT_CALL设置 3. 参数匹配器 4. 调用次数控制 | Mock基础示例 |
| Day 23 | 5h | GMock高级 | 1. InSequence调用序列 2. 自定义Action 3. SaveArg/SetArg 4. NiceMock/StrictMock | 高级Mock示例 |
| Day 24 | 5h | 测试替身模式 | 1. Mock vs Stub 2. Fake vs Spy 3. 选择决策树 4. 实际案例分析 | 替身模式文档 |
| Day 25 | 5h | 可测试性设计 | 1. 依赖注入原则 2. 接口隔离 3. 测试难点与重构 4. 遗留代码测试策略 | 设计模式示例 |
| Day 26 | 5h | TDD实践(上) | 1. 红绿重构循环 2. FIRST原则深入 3. TDD开始JSON解析器 | TDD项目（部分） |
| Day 27 | 5h | TDD实践(下) | 1. 继续TDD开发 2. 重构技巧 3. 测试代码坏味道 | TDD项目（完成） |
| Day 28 | 5h | 覆盖率与总结 | 1. gcov/lcov工具 2. 覆盖率报告生成 3. CI集成 4. 月度总结 | 覆盖率配置+笔记 |

---

**学习目标**：掌握Mock测试和测试设计原则

**阅读材料**：
- [ ] Google Mock文档
- [ ] 《单元测试的艺术》
- [ ] FIRST原则

```cpp
// ==========================================
// Google Mock基础
// ==========================================
#include <gmock/gmock.h>
#include <gtest/gtest.h>

// 接口定义
class HttpClient {
public:
    virtual ~HttpClient() = default;
    virtual std::string get(const std::string& url) = 0;
    virtual int post(const std::string& url, const std::string& body) = 0;
};

// Mock类
class MockHttpClient : public HttpClient {
public:
    MOCK_METHOD(std::string, get, (const std::string& url), (override));
    MOCK_METHOD(int, post, (const std::string& url, const std::string& body), (override));
};

// 使用Mock
TEST(ApiClientTest, FetchData) {
    MockHttpClient mockHttp;

    // 设置期望
    EXPECT_CALL(mockHttp, get("https://api.example.com/data"))
        .Times(1)
        .WillOnce(::testing::Return(R"({"status": "ok"})"));

    ApiClient client(&mockHttp);
    auto result = client.fetchData();

    EXPECT_EQ(result.status, "ok");
}

// ==========================================
// Mock高级用法
// ==========================================

// 参数匹配器
using namespace ::testing;

EXPECT_CALL(mock, method(_));                    // 任意参数
EXPECT_CALL(mock, method(Eq(42)));              // 等于42
EXPECT_CALL(mock, method(Gt(0)));               // 大于0
EXPECT_CALL(mock, method(HasSubstr("test")));   // 包含子串
EXPECT_CALL(mock, method(StartsWith("http"))); // 以...开头
EXPECT_CALL(mock, method(MatchesRegex(".*")));  // 正则匹配
EXPECT_CALL(mock, method(AllOf(Gt(0), Lt(100)))); // 组合条件

// 调用次数
EXPECT_CALL(mock, method()).Times(0);           // 不被调用
EXPECT_CALL(mock, method()).Times(1);           // 恰好1次
EXPECT_CALL(mock, method()).Times(AtLeast(1));  // 至少1次
EXPECT_CALL(mock, method()).Times(AtMost(3));   // 最多3次
EXPECT_CALL(mock, method()).Times(Between(2, 5)); // 2-5次

// 返回值设置
EXPECT_CALL(mock, method())
    .WillOnce(Return(42))
    .WillOnce(Return(100))
    .WillRepeatedly(Return(0));

// 副作用
EXPECT_CALL(mock, method(_))
    .WillOnce(DoAll(
        SaveArg<0>(&saved_value),  // 保存参数
        SetArgReferee<1>(100),     // 设置引用参数
        Return(true)
    ));

// 调用序列
{
    InSequence seq;
    EXPECT_CALL(mock, init());
    EXPECT_CALL(mock, process());
    EXPECT_CALL(mock, cleanup());
}

// 自定义行为
EXPECT_CALL(mock, compute(_))
    .WillOnce([](int x) { return x * 2; });
```

```cpp
// ==========================================
// 测试设计示例
// ==========================================

// FIRST原则：
// Fast - 快速执行
// Independent - 测试间独立
// Repeatable - 可重复执行
// Self-validating - 自验证
// Timely - 及时编写
```

#### 测试替身（Test Double）模式详解

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    测试替身（Test Double）分类                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────┬────────────────────────────────────────────────────────┐  │
│  │ 类型         │ 说明                                                   │  │
│  ├─────────────┼────────────────────────────────────────────────────────┤  │
│  │             │                                                        │  │
│  │   Dummy     │ 传入但不使用的对象，仅满足参数签名                      │  │
│  │             │ 例：func(DummyLogger{}) 但 func 内不调用 Logger        │  │
│  │             │                                                        │  │
│  ├─────────────┼────────────────────────────────────────────────────────┤  │
│  │             │                                                        │  │
│  │   Stub      │ 返回预设值，不验证调用方式                              │  │
│  │             │ 例：StubDB.getUser() 总是返回固定User对象              │  │
│  │             │ 关注：状态验证（检查函数返回值）                        │  │
│  │             │                                                        │  │
│  ├─────────────┼────────────────────────────────────────────────────────┤  │
│  │             │                                                        │  │
│  │   Fake      │ 有简化的工作实现                                        │  │
│  │             │ 例：InMemoryDB 代替真实数据库                          │  │
│  │             │ 比Stub更完整，可能有自己的测试                          │  │
│  │             │                                                        │  │
│  ├─────────────┼────────────────────────────────────────────────────────┤  │
│  │             │                                                        │  │
│  │   Spy       │ 记录调用信息，事后验证                                  │  │
│  │             │ 例：SpyMailer.send() 记录发送次数和参数                │  │
│  │             │ 测试后检查：spy.callCount == 1                         │  │
│  │             │                                                        │  │
│  ├─────────────┼────────────────────────────────────────────────────────┤  │
│  │             │                                                        │  │
│  │   Mock      │ 预设期望，自动验证调用方式                              │  │
│  │             │ 例：EXPECT_CALL(mock, send(_)).Times(1)                │  │
│  │             │ 关注：行为验证（检查方法是否被正确调用）                │  │
│  │             │                                                        │  │
│  └─────────────┴────────────────────────────────────────────────────────┘  │
│                                                                             │
│  选择决策：                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                  需要验证交互行为？                                   │   │
│  │                        │                                             │   │
│  │               ┌────────┴────────┐                                   │   │
│  │               │                 │                                    │   │
│  │              是                否                                    │   │
│  │               │                 │                                    │   │
│  │               ▼                 ▼                                    │   │
│  │         需要严格顺序？    需要简化实现？                              │   │
│  │          │        │        │        │                                │   │
│  │         是       否       是       否                                │   │
│  │          │        │        │        │                                │   │
│  │          ▼        ▼        ▼        ▼                                │   │
│  │     ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐                            │   │
│  │     │ Mock │ │ Spy  │ │ Fake │ │ Stub │                            │   │
│  │     │序列  │ │记录  │ │简化  │ │固定  │                            │   │
│  │     │验证  │ │后验  │ │实现  │ │返回  │                            │   │
│  │     └──────┘ └──────┘ └──────┘ └──────┘                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  GMock中的Mock严格度：                                                       │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ NiceMock<T>     │ 忽略没有 EXPECT_CALL 的调用（不警告）             │    │
│  │ NaggyMock<T>    │ 对没有期望的调用产生警告（默认行为）              │    │
│  │ StrictMock<T>   │ 对没有期望的调用产生失败（最严格）                │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### FIRST原则深入理解

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        FIRST 原则                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   F ─ Fast（快速）                                                           │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │ • 单个测试应在毫秒级完成                                            │   │
│   │ • 整个测试套件应在秒级完成                                          │   │
│   │ • 避免：文件IO、网络调用、数据库操作、sleep                         │   │
│   │ • 解决：用Mock/Fake替代外部依赖                                     │   │
│   └────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   I ─ Independent（独立）                                                    │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │ • 测试之间无顺序依赖                                                │   │
│   │ • 可以单独运行任何一个测试                                          │   │
│   │ • 验证方法：--gtest_shuffle 随机顺序运行                            │   │
│   │ • 避免：全局状态、共享可变数据、测试间传递值                        │   │
│   └────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   R ─ Repeatable（可重复）                                                   │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │ • 任何时间任何环境运行结果一致                                      │   │
│   │ • 不依赖：当前时间、随机数、网络、外部服务                          │   │
│   │ • 使用固定种子的随机数、注入时间源                                  │   │
│   │ • Flaky test（不稳定测试）是团队效率杀手                            │   │
│   └────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   S ─ Self-validating（自验证）                                              │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │ • 结果只有 PASS 或 FAIL，无需人工检查                               │   │
│   │ • 不要：打印日志让人看，手动比较输出文件                            │   │
│   │ • 使用明确的断言表达期望结果                                        │   │
│   │ • 失败信息应足够诊断问题（使用自定义消息）                          │   │
│   └────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│   T ─ Timely（及时）                                                         │
│   ┌────────────────────────────────────────────────────────────────────┐   │
│   │ • 在编写生产代码之前或同时编写测试（TDD）                           │   │
│   │ • 不要等功能完成后再补测试                                          │   │
│   │ • 测试驱动的代码天然更可测试                                        │   │
│   │ • 越晚补测试，越难写（代码耦合度高）                                │   │
│   └────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### TDD红绿重构循环

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    TDD（Test-Driven Development）                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                         ┌──────────────────┐                                │
│                         │   1. RED 🔴      │                                │
│                         │   写一个失败的    │                                │
│                         │   测试           │                                │
│                         └────────┬─────────┘                                │
│                                  │                                          │
│                                  ▼                                          │
│         ┌──────────────────┐                ┌──────────────────┐           │
│         │  3. REFACTOR 🔵 │◀──────────────│  2. GREEN 🟢    │           │
│         │  改善代码结构    │                │  用最简单的方式  │           │
│         │  保持测试通过    │                │  让测试通过      │           │
│         └────────┬─────────┘                └──────────────────┘           │
│                  │                                                          │
│                  └────────────────────▶ 回到步骤1，写下一个测试             │
│                                                                             │
│  TDD流程详解：                                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  RED阶段（编写测试）:                                                │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ 1. 思考下一个最小的功能增量                                  │    │   │
│  │  │ 2. 编写一个描述该行为的测试                                  │    │   │
│  │  │ 3. 运行测试 → 确认它失败（编译失败也算）                    │    │   │
│  │  │ 4. 如果测试意外通过 → 测试可能不够具体                     │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  │  GREEN阶段（实现功能）:                                              │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ 1. 写刚好足够让测试通过的代码                                │    │   │
│  │  │ 2. 不要过度设计，不要"顺便"加功能                           │    │   │
│  │  │ 3. 硬编码返回值也是可以接受的起点                            │    │   │
│  │  │ 4. 运行测试 → 确认它通过                                    │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  │  REFACTOR阶段（改善结构）:                                           │   │
│  │  ┌────────────────────────────────────────────────────────────┐    │   │
│  │  │ 1. 消除重复代码（生产代码和测试代码）                        │    │   │
│  │  │ 2. 改善命名、提取函数、简化逻辑                              │    │   │
│  │  │ 3. 每次小改动后运行测试                                      │    │   │
│  │  │ 4. 重构不改变外部行为，只改善内部结构                        │    │   │
│  │  └────────────────────────────────────────────────────────────┘    │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  TDD示例（栈实现）:                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ // Round 1: RED → 空栈应该为空                                     │    │
│  │ TEST(Stack, EmptyOnConstruction) {                                 │    │
│  │     Stack<int> s;                                                  │    │
│  │     EXPECT_TRUE(s.empty());        // 编译失败: Stack未定义        │    │
│  │ }                                                                  │    │
│  │                                                                     │    │
│  │ // Round 1: GREEN → 最小实现                                       │    │
│  │ template<typename T> struct Stack { bool empty() { return true; }}; │    │
│  │                                                                     │    │
│  │ // Round 2: RED → push后不为空                                     │    │
│  │ TEST(Stack, NotEmptyAfterPush) {                                   │    │
│  │     Stack<int> s;                                                  │    │
│  │     s.push(42);                                                    │    │
│  │     EXPECT_FALSE(s.empty());       // 失败: 总是返回true           │    │
│  │ }                                                                  │    │
│  │                                                                     │    │
│  │ // Round 2: GREEN → 添加真正的实现                                 │    │
│  │ // Round 3: RED → pop应该返回最后push的值                          │    │
│  │ // ... 循环继续                                                     │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 依赖注入与可测试性设计

```cpp
// ==========================================
// 可测试性设计模式
// ==========================================

// ❌ 不可测试的设计——硬编码依赖
class ReportGenerator_Bad {
public:
    std::string generate() {
        Database db("prod_server");        // 硬编码数据库连接
        auto data = db.query("SELECT *");  // 无法在测试中替换
        return format(data);
    }
};

// ✅ 可测试的设计——依赖注入
class ReportGenerator_Good {
public:
    // 构造函数注入：通过接口传入依赖
    explicit ReportGenerator_Good(std::shared_ptr<IDatabase> db)
        : db_(std::move(db)) {}

    std::string generate() {
        auto data = db_->query("SELECT *");  // 可用Mock替换
        return format(data);
    }

private:
    std::shared_ptr<IDatabase> db_;
};

// 生产代码
auto report = ReportGenerator_Good(
    std::make_shared<PostgresDatabase>("prod")
);

// 测试代码
auto mockDb = std::make_shared<MockDatabase>();
EXPECT_CALL(*mockDb, query(_)).WillOnce(Return(testData));
auto report = ReportGenerator_Good(mockDb);
```

```cpp

// 被测类
class OrderProcessor {
public:
    explicit OrderProcessor(
        std::shared_ptr<Database> db,
        std::shared_ptr<PaymentGateway> payment,
        std::shared_ptr<EmailService> email
    ) : db_(db), payment_(payment), email_(email) {}

    enum class Result {
        Success,
        PaymentFailed,
        InsufficientStock,
        DatabaseError
    };

    Result processOrder(const Order& order) {
        // 检查库存
        auto product = db_->getProduct(order.productId);
        if (!product || product->stock < order.quantity) {
            return Result::InsufficientStock;
        }

        // 处理支付
        auto paymentResult = payment_->charge(
            order.customerId,
            order.quantity * product->price
        );
        if (!paymentResult.success) {
            return Result::PaymentFailed;
        }

        // 更新库存
        product->stock -= order.quantity;
        if (!db_->updateProduct(*product)) {
            payment_->refund(paymentResult.transactionId);
            return Result::DatabaseError;
        }

        // 发送确认邮件
        email_->sendOrderConfirmation(order.customerId, order);

        return Result::Success;
    }

private:
    std::shared_ptr<Database> db_;
    std::shared_ptr<PaymentGateway> payment_;
    std::shared_ptr<EmailService> email_;
};

// Mock接口
class MockDatabase : public Database {
public:
    MOCK_METHOD(std::optional<Product>, getProduct, (int id), (override));
    MOCK_METHOD(bool, updateProduct, (const Product& p), (override));
};

class MockPaymentGateway : public PaymentGateway {
public:
    MOCK_METHOD(PaymentResult, charge, (int customerId, double amount), (override));
    MOCK_METHOD(bool, refund, (const std::string& transactionId), (override));
};

class MockEmailService : public EmailService {
public:
    MOCK_METHOD(void, sendOrderConfirmation, (int customerId, const Order& order), (override));
};

// 测试类
class OrderProcessorTest : public ::testing::Test {
protected:
    void SetUp() override {
        mockDb_ = std::make_shared<MockDatabase>();
        mockPayment_ = std::make_shared<MockPaymentGateway>();
        mockEmail_ = std::make_shared<MockEmailService>();

        processor_ = std::make_unique<OrderProcessor>(
            mockDb_, mockPayment_, mockEmail_
        );

        // 默认产品
        defaultProduct_ = Product{1, "Test Product", 10.0, 100};
    }

    std::shared_ptr<MockDatabase> mockDb_;
    std::shared_ptr<MockPaymentGateway> mockPayment_;
    std::shared_ptr<MockEmailService> mockEmail_;
    std::unique_ptr<OrderProcessor> processor_;
    Product defaultProduct_;
};

TEST_F(OrderProcessorTest, SuccessfulOrder) {
    Order order{1, 1, 5};  // customerId=1, productId=1, quantity=5

    EXPECT_CALL(*mockDb_, getProduct(1))
        .WillOnce(Return(defaultProduct_));

    EXPECT_CALL(*mockPayment_, charge(1, 50.0))
        .WillOnce(Return(PaymentResult{true, "tx123"}));

    EXPECT_CALL(*mockDb_, updateProduct(_))
        .WillOnce(Return(true));

    EXPECT_CALL(*mockEmail_, sendOrderConfirmation(1, _))
        .Times(1);

    auto result = processor_->processOrder(order);
    EXPECT_EQ(result, OrderProcessor::Result::Success);
}

TEST_F(OrderProcessorTest, InsufficientStock) {
    Order order{1, 1, 200};  // 超过库存

    EXPECT_CALL(*mockDb_, getProduct(1))
        .WillOnce(Return(defaultProduct_));

    // 支付和邮件不应被调用
    EXPECT_CALL(*mockPayment_, charge(_, _)).Times(0);
    EXPECT_CALL(*mockEmail_, sendOrderConfirmation(_, _)).Times(0);

    auto result = processor_->processOrder(order);
    EXPECT_EQ(result, OrderProcessor::Result::InsufficientStock);
}

TEST_F(OrderProcessorTest, PaymentFailed) {
    Order order{1, 1, 5};

    EXPECT_CALL(*mockDb_, getProduct(1))
        .WillOnce(Return(defaultProduct_));

    EXPECT_CALL(*mockPayment_, charge(1, 50.0))
        .WillOnce(Return(PaymentResult{false, ""}));

    // 库存不应更新，邮件不应发送
    EXPECT_CALL(*mockDb_, updateProduct(_)).Times(0);
    EXPECT_CALL(*mockEmail_, sendOrderConfirmation(_, _)).Times(0);

    auto result = processor_->processOrder(order);
    EXPECT_EQ(result, OrderProcessor::Result::PaymentFailed);
}

TEST_F(OrderProcessorTest, DatabaseErrorTriggersRefund) {
    Order order{1, 1, 5};

    EXPECT_CALL(*mockDb_, getProduct(1))
        .WillOnce(Return(defaultProduct_));

    EXPECT_CALL(*mockPayment_, charge(1, 50.0))
        .WillOnce(Return(PaymentResult{true, "tx123"}));

    EXPECT_CALL(*mockDb_, updateProduct(_))
        .WillOnce(Return(false));  // 数据库错误

    // 应该触发退款
    EXPECT_CALL(*mockPayment_, refund("tx123"))
        .WillOnce(Return(true));

    auto result = processor_->processOrder(order);
    EXPECT_EQ(result, OrderProcessor::Result::DatabaseError);
}
```

#### 代码覆盖率工具链

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      代码覆盖率工具链                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  覆盖率类型：                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 行覆盖率 (Line Coverage)     │ 每一行代码是否被执行                  │   │
│  │ 分支覆盖率 (Branch Coverage) │ 每个if/else分支是否都被走到           │   │
│  │ 函数覆盖率 (Function Cov.)   │ 每个函数是否被调用                    │   │
│  │ 条件覆盖率 (Condition Cov.)  │ 布尔表达式的每个子条件                │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  GCC工具链 (gcov + lcov):                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐  │   │
│  │  │编译加  │──▶│运行    │──▶│ gcov   │──▶│ lcov   │──▶│genhtml │  │   │
│  │  │覆盖率  │   │测试    │   │ 收集   │   │ 过滤   │   │ 生成   │  │   │
│  │  │flags  │   │程序    │   │ .gcda  │   │ 聚合   │   │ HTML   │  │   │
│  │  └────────┘   └────────┘   └────────┘   └────────┘   └────────┘  │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  Clang工具链 (llvm-cov):                                                     │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                                                                     │   │
│  │  ┌──────────┐   ┌─────────┐   ┌────────────┐   ┌──────────────┐  │   │
│  │  │编译加    │──▶│运行后   │──▶│llvm-profdata│──▶│ llvm-cov     │  │   │
│  │  │-fprofile │   │生成     │   │ merge      │   │ show/report  │  │   │
│  │  │-instr    │   │.profraw │   │ .profdata  │   │ HTML报告     │  │   │
│  │  └──────────┘   └─────────┘   └────────────┘   └──────────────┘  │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

```cmake
# ==========================================
# CMake覆盖率配置
# ==========================================

# 方式1：GCC/gcov
option(ENABLE_COVERAGE "Enable code coverage" OFF)

if(ENABLE_COVERAGE)
    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU")
        add_compile_options(--coverage -fprofile-arcs -ftest-coverage)
        add_link_options(--coverage)
    elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        add_compile_options(-fprofile-instr-generate -fcoverage-mapping)
        add_link_options(-fprofile-instr-generate)
    endif()
endif()

# 自定义target生成覆盖率报告
add_custom_target(coverage
    COMMAND ${CMAKE_CTEST_COMMAND} --test-dir ${CMAKE_BINARY_DIR}
    COMMAND lcov --capture
           --directory ${CMAKE_BINARY_DIR}
           --output-file coverage.info
           --ignore-errors mismatch
    COMMAND lcov --remove coverage.info
           '/usr/*' '*/test/*' '*/vcpkg_installed/*'
           --output-file coverage_filtered.info
    COMMAND genhtml coverage_filtered.info
           --output-directory coverage_report
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    COMMENT "Generating code coverage report..."
)
```

```bash
# ==========================================
# 覆盖率生成命令
# ==========================================

# GCC + lcov方式
cmake -B build -DENABLE_COVERAGE=ON -DCMAKE_BUILD_TYPE=Debug
cmake --build build
cd build && ctest
lcov --capture --directory . --output-file coverage.info
lcov --remove coverage.info '/usr/*' '*/test/*' -o coverage_filtered.info
genhtml coverage_filtered.info --output-directory coverage_report
# 打开 coverage_report/index.html 查看报告

# Clang + llvm-cov方式
cmake -B build -DENABLE_COVERAGE=ON -DCMAKE_CXX_COMPILER=clang++
cmake --build build
LLVM_PROFILE_FILE="test.profraw" ./build/tests
llvm-profdata merge -sparse test.profraw -o test.profdata
llvm-cov show ./build/tests -instr-profile=test.profdata \
    --format=html -output-dir=coverage_report
```

#### 测试代码坏味道

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      测试代码坏味道（Test Smells）                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 巨大测试（Giant Test）                                                   │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 症状：单个测试验证太多东西，难以定位失败原因                        │    │
│  │ 修复：拆分为多个独立测试，每个测试验证一个行为                      │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  2. 神秘访客（Mystery Guest）                                                │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 症状：测试依赖外部文件/数据库，不看外部资源无法理解测试             │    │
│  │ 修复：测试内联必要数据，使用Builder模式构造测试对象                 │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  3. 脆弱测试（Fragile Test）                                                 │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 症状：代码小改动导致大量测试失败                                    │    │
│  │ 修复：测试行为而非实现，减少对内部细节的依赖                        │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  4. 过度Mock（Mock Overuse）                                                 │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 症状：Mock了太多对象，测试变成了对实现的镜像                        │    │
│  │ 修复：只Mock外部依赖边界，优先使用Fake或真实的轻量实现             │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  5. 测试间耦合（Test Coupling）                                              │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 症状：测试依赖执行顺序，共享可变状态                                │    │
│  │ 修复：每个测试独立SetUp，使用 --gtest_shuffle 验证                  │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  6. 测试无断言（Assertion-Free Test）                                        │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ 症状：测试只调用代码不验证结果（"happy path"测试）                  │    │
│  │ 修复：每个测试至少有一个有意义的断言                                │    │
│  └────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
│  覆盖率误区：                                                                │
│  ┌────────────────────────────────────────────────────────────────────┐    │
│  │ • 100%覆盖率 ≠ 没有bug （可能缺少边界条件测试）                    │    │
│  │ • 高覆盖率 ≠ 好测试 （没有断言的测试也能提高覆盖率）               │    │
│  │ • 合理目标：核心业务逻辑 >90%，总体 >70%                           │    │
│  │ • 关注：分支覆盖率比行覆盖率更有价值                                │    │
│  └────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Week 4 输出物清单

| 类别 | 文件/目录 | 说明 |
|------|-----------|------|
| Mock示例 | `mock_tests/test_mock_basic.cpp` | GMock基础与高级用法 |
| Mock示例 | `mock_tests/test_order_processor.cpp` | 完整Mock集成测试 |
| 替身模式 | `mock_tests/test_doubles.cpp` | Dummy/Stub/Fake/Spy示例 |
| TDD项目 | `json-parser/` | TDD方式开发的JSON解析器 |
| 覆盖率 | `cmake/Coverage.cmake` | 覆盖率CMake模块 |
| 覆盖率 | `coverage_report/` | 生成的HTML覆盖率报告 |
| 学习笔记 | `notes/week4_mock_tdd.md` | Mock和TDD总结 |

#### Week 4 检验标准

- [ ] 能使用MOCK_METHOD和EXPECT_CALL
- [ ] 理解并能使用参数匹配器
- [ ] 能区分Mock/Stub/Fake/Spy的使用场景
- [ ] 理解依赖注入对可测试性的重要性
- [ ] 能按TDD流程开发简单功能
- [ ] 能配置和生成代码覆盖率报告
- [ ] 能识别测试代码坏味道并重构

---

## 源码阅读任务

### 本月源码阅读

1. **Google Test源码**
   - 仓库：https://github.com/google/googletest
   - 重点：`googletest/src/gtest.cc`
   - 学习目标：理解断言宏的实现

2. **Catch2源码**
   - 仓库：https://github.com/catchorg/Catch2
   - 重点：`src/catch2/`
   - 学习目标：理解SECTION的实现原理

3. **知名项目的测试**
   - fmt库的测试
   - nlohmann/json的测试

---

## 实践项目

### 项目：测试驱动开发的JSON解析器

使用TDD方法开发一个简单的JSON解析器。

**项目结构**：

```
json-parser/
├── CMakeLists.txt
├── vcpkg.json
├── include/
│   └── jsonparser/
│       ├── json.hpp
│       ├── parser.hpp
│       └── value.hpp
├── src/
│   ├── parser.cpp
│   └── value.cpp
└── tests/
    ├── CMakeLists.txt
    ├── test_value.cpp
    ├── test_parser.cpp
    └── test_integration.cpp
```

**tests/CMakeLists.txt**：

```cmake
find_package(GTest CONFIG REQUIRED)
find_package(Catch2 3 CONFIG REQUIRED)

# Google Test测试
add_executable(gtest_tests
    test_value.cpp
    test_parser.cpp
)

target_link_libraries(gtest_tests
    PRIVATE
        jsonparser
        GTest::gtest
        GTest::gtest_main
        GTest::gmock
)

include(GoogleTest)
gtest_discover_tests(gtest_tests)

# Catch2测试
add_executable(catch2_tests
    test_integration.cpp
)

target_link_libraries(catch2_tests
    PRIVATE
        jsonparser
        Catch2::Catch2WithMain
)

include(CTest)
include(Catch)
catch_discover_tests(catch2_tests)
```

**include/jsonparser/value.hpp**：

```cpp
#pragma once

#include <string>
#include <vector>
#include <map>
#include <variant>
#include <memory>
#include <stdexcept>

namespace jsonparser {

class JsonValue;

using JsonNull = std::nullptr_t;
using JsonBool = bool;
using JsonNumber = double;
using JsonString = std::string;
using JsonArray = std::vector<JsonValue>;
using JsonObject = std::map<std::string, JsonValue>;

class JsonError : public std::runtime_error {
public:
    using std::runtime_error::runtime_error;
};

class JsonValue {
public:
    using ValueType = std::variant<
        JsonNull,
        JsonBool,
        JsonNumber,
        JsonString,
        JsonArray,
        JsonObject
    >;

    // 构造函数
    JsonValue() : value_(nullptr) {}
    JsonValue(std::nullptr_t) : value_(nullptr) {}
    JsonValue(bool b) : value_(b) {}
    JsonValue(int n) : value_(static_cast<double>(n)) {}
    JsonValue(double n) : value_(n) {}
    JsonValue(const char* s) : value_(std::string(s)) {}
    JsonValue(std::string s) : value_(std::move(s)) {}
    JsonValue(JsonArray arr) : value_(std::move(arr)) {}
    JsonValue(JsonObject obj) : value_(std::move(obj)) {}

    // 类型检查
    bool is_null() const { return std::holds_alternative<JsonNull>(value_); }
    bool is_bool() const { return std::holds_alternative<JsonBool>(value_); }
    bool is_number() const { return std::holds_alternative<JsonNumber>(value_); }
    bool is_string() const { return std::holds_alternative<JsonString>(value_); }
    bool is_array() const { return std::holds_alternative<JsonArray>(value_); }
    bool is_object() const { return std::holds_alternative<JsonObject>(value_); }

    // 值获取
    template<typename T>
    T& get() { return std::get<T>(value_); }

    template<typename T>
    const T& get() const { return std::get<T>(value_); }

    // 便捷访问
    bool as_bool() const { return get<JsonBool>(); }
    double as_number() const { return get<JsonNumber>(); }
    const std::string& as_string() const { return get<JsonString>(); }
    const JsonArray& as_array() const { return get<JsonArray>(); }
    const JsonObject& as_object() const { return get<JsonObject>(); }

    // 数组访问
    JsonValue& operator[](size_t index);
    const JsonValue& operator[](size_t index) const;

    // 对象访问
    JsonValue& operator[](const std::string& key);
    const JsonValue& operator[](const std::string& key) const;

    // 大小
    size_t size() const;

    // 比较
    bool operator==(const JsonValue& other) const;
    bool operator!=(const JsonValue& other) const { return !(*this == other); }

    // 序列化
    std::string dump(int indent = -1) const;

private:
    ValueType value_;

    std::string dump_impl(int indent, int current_indent) const;
};

} // namespace jsonparser
```

**tests/test_value.cpp**：

```cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <jsonparser/value.hpp>

using namespace jsonparser;
using namespace ::testing;

class JsonValueTest : public ::testing::Test {
protected:
    void SetUp() override {}
};

// ==========================================
// 构造函数测试
// ==========================================
TEST_F(JsonValueTest, DefaultConstructorCreatesNull) {
    JsonValue v;
    EXPECT_TRUE(v.is_null());
}

TEST_F(JsonValueTest, NullptrConstructor) {
    JsonValue v(nullptr);
    EXPECT_TRUE(v.is_null());
}

TEST_F(JsonValueTest, BoolConstructor) {
    JsonValue t(true);
    JsonValue f(false);

    EXPECT_TRUE(t.is_bool());
    EXPECT_TRUE(f.is_bool());
    EXPECT_TRUE(t.as_bool());
    EXPECT_FALSE(f.as_bool());
}

TEST_F(JsonValueTest, NumberConstructor) {
    JsonValue i(42);
    JsonValue d(3.14);

    EXPECT_TRUE(i.is_number());
    EXPECT_TRUE(d.is_number());
    EXPECT_DOUBLE_EQ(i.as_number(), 42.0);
    EXPECT_DOUBLE_EQ(d.as_number(), 3.14);
}

TEST_F(JsonValueTest, StringConstructor) {
    JsonValue s1("hello");
    JsonValue s2(std::string("world"));

    EXPECT_TRUE(s1.is_string());
    EXPECT_TRUE(s2.is_string());
    EXPECT_EQ(s1.as_string(), "hello");
    EXPECT_EQ(s2.as_string(), "world");
}

TEST_F(JsonValueTest, ArrayConstructor) {
    JsonArray arr = {1, 2, 3};
    JsonValue v(arr);

    EXPECT_TRUE(v.is_array());
    EXPECT_EQ(v.size(), 3);
}

TEST_F(JsonValueTest, ObjectConstructor) {
    JsonObject obj = {{"key", "value"}};
    JsonValue v(obj);

    EXPECT_TRUE(v.is_object());
    EXPECT_EQ(v.size(), 1);
}

// ==========================================
// 类型检查测试
// ==========================================
class JsonValueTypeTest : public ::testing::TestWithParam<std::tuple<JsonValue, std::string>> {};

TEST_P(JsonValueTypeTest, OnlyOneTypeReturnsTrue) {
    auto [value, expected_type] = GetParam();

    if (expected_type == "null") {
        EXPECT_TRUE(value.is_null());
    } else {
        EXPECT_FALSE(value.is_null());
    }

    if (expected_type == "bool") {
        EXPECT_TRUE(value.is_bool());
    } else {
        EXPECT_FALSE(value.is_bool());
    }

    if (expected_type == "number") {
        EXPECT_TRUE(value.is_number());
    } else {
        EXPECT_FALSE(value.is_number());
    }

    if (expected_type == "string") {
        EXPECT_TRUE(value.is_string());
    } else {
        EXPECT_FALSE(value.is_string());
    }

    if (expected_type == "array") {
        EXPECT_TRUE(value.is_array());
    } else {
        EXPECT_FALSE(value.is_array());
    }

    if (expected_type == "object") {
        EXPECT_TRUE(value.is_object());
    } else {
        EXPECT_FALSE(value.is_object());
    }
}

INSTANTIATE_TEST_SUITE_P(
    AllTypes,
    JsonValueTypeTest,
    ::testing::Values(
        std::make_tuple(JsonValue(nullptr), "null"),
        std::make_tuple(JsonValue(true), "bool"),
        std::make_tuple(JsonValue(42), "number"),
        std::make_tuple(JsonValue("str"), "string"),
        std::make_tuple(JsonValue(JsonArray{}), "array"),
        std::make_tuple(JsonValue(JsonObject{}), "object")
    )
);

// ==========================================
// 访问器测试
// ==========================================
TEST_F(JsonValueTest, ArrayAccess) {
    JsonValue arr(JsonArray{1, 2, 3});

    EXPECT_DOUBLE_EQ(arr[0].as_number(), 1);
    EXPECT_DOUBLE_EQ(arr[1].as_number(), 2);
    EXPECT_DOUBLE_EQ(arr[2].as_number(), 3);
}

TEST_F(JsonValueTest, ArrayAccessOutOfBounds) {
    JsonValue arr(JsonArray{1});

    EXPECT_THROW(arr[10], std::out_of_range);
}

TEST_F(JsonValueTest, ObjectAccess) {
    JsonValue obj(JsonObject{{"name", "John"}, {"age", 30}});

    EXPECT_EQ(obj["name"].as_string(), "John");
    EXPECT_DOUBLE_EQ(obj["age"].as_number(), 30);
}

TEST_F(JsonValueTest, ObjectAccessNonExistent) {
    JsonValue obj(JsonObject{});

    // 访问不存在的键应该返回null
    EXPECT_TRUE(obj["missing"].is_null());
}

// ==========================================
// 比较测试
// ==========================================
TEST_F(JsonValueTest, EqualityNull) {
    EXPECT_EQ(JsonValue(nullptr), JsonValue(nullptr));
}

TEST_F(JsonValueTest, EqualityBool) {
    EXPECT_EQ(JsonValue(true), JsonValue(true));
    EXPECT_NE(JsonValue(true), JsonValue(false));
}

TEST_F(JsonValueTest, EqualityNumber) {
    EXPECT_EQ(JsonValue(42), JsonValue(42));
    EXPECT_EQ(JsonValue(42), JsonValue(42.0));
    EXPECT_NE(JsonValue(42), JsonValue(43));
}

TEST_F(JsonValueTest, EqualityString) {
    EXPECT_EQ(JsonValue("hello"), JsonValue("hello"));
    EXPECT_NE(JsonValue("hello"), JsonValue("world"));
}

TEST_F(JsonValueTest, EqualityArray) {
    EXPECT_EQ(
        JsonValue(JsonArray{1, 2, 3}),
        JsonValue(JsonArray{1, 2, 3})
    );
    EXPECT_NE(
        JsonValue(JsonArray{1, 2, 3}),
        JsonValue(JsonArray{1, 2, 4})
    );
}

TEST_F(JsonValueTest, EqualityDifferentTypes) {
    EXPECT_NE(JsonValue(42), JsonValue("42"));
    EXPECT_NE(JsonValue(nullptr), JsonValue(false));
}

// ==========================================
// 序列化测试
// ==========================================
TEST_F(JsonValueTest, DumpNull) {
    EXPECT_EQ(JsonValue(nullptr).dump(), "null");
}

TEST_F(JsonValueTest, DumpBool) {
    EXPECT_EQ(JsonValue(true).dump(), "true");
    EXPECT_EQ(JsonValue(false).dump(), "false");
}

TEST_F(JsonValueTest, DumpNumber) {
    EXPECT_EQ(JsonValue(42).dump(), "42");
    EXPECT_EQ(JsonValue(3.14).dump(), "3.14");
}

TEST_F(JsonValueTest, DumpString) {
    EXPECT_EQ(JsonValue("hello").dump(), "\"hello\"");
    EXPECT_EQ(JsonValue("hello\nworld").dump(), "\"hello\\nworld\"");
}

TEST_F(JsonValueTest, DumpEmptyArray) {
    EXPECT_EQ(JsonValue(JsonArray{}).dump(), "[]");
}

TEST_F(JsonValueTest, DumpArray) {
    JsonValue arr(JsonArray{1, 2, 3});
    EXPECT_EQ(arr.dump(), "[1,2,3]");
}

TEST_F(JsonValueTest, DumpEmptyObject) {
    EXPECT_EQ(JsonValue(JsonObject{}).dump(), "{}");
}

TEST_F(JsonValueTest, DumpObject) {
    JsonValue obj(JsonObject{{"key", "value"}});
    EXPECT_EQ(obj.dump(), "{\"key\":\"value\"}");
}

TEST_F(JsonValueTest, DumpPrettyPrint) {
    JsonValue obj(JsonObject{
        {"name", "John"},
        {"age", 30}
    });

    std::string expected = R"({
  "age": 30,
  "name": "John"
})";

    EXPECT_EQ(obj.dump(2), expected);
}
```

**tests/test_integration.cpp**（Catch2）：

```cpp
#include <catch2/catch_test_macros.hpp>
#include <catch2/catch_approx.hpp>
#include <catch2/matchers/catch_matchers_string.hpp>
#include <catch2/generators/catch_generators.hpp>

#include <jsonparser/json.hpp>

using namespace jsonparser;
using namespace Catch::Matchers;

TEST_CASE("JSON parsing and roundtrip", "[integration]") {
    SECTION("Simple values") {
        auto json_str = GENERATE(
            "null",
            "true",
            "false",
            "42",
            "3.14",
            "\"hello\"",
            "[]",
            "{}"
        );

        CAPTURE(json_str);

        auto parsed = Json::parse(json_str);
        auto dumped = parsed.dump();

        // 重新解析应该得到相同结果
        auto reparsed = Json::parse(dumped);
        REQUIRE(parsed == reparsed);
    }

    SECTION("Complex nested structure") {
        std::string json = R"({
            "name": "John",
            "age": 30,
            "active": true,
            "address": {
                "city": "New York",
                "zip": "10001"
            },
            "tags": ["developer", "c++"],
            "score": null
        })";

        auto parsed = Json::parse(json);

        REQUIRE(parsed["name"].as_string() == "John");
        REQUIRE(parsed["age"].as_number() == Catch::Approx(30));
        REQUIRE(parsed["active"].as_bool() == true);
        REQUIRE(parsed["address"]["city"].as_string() == "New York");
        REQUIRE(parsed["tags"][0].as_string() == "developer");
        REQUIRE(parsed["score"].is_null());
    }
}

SCENARIO("Building JSON programmatically", "[builder]") {
    GIVEN("An empty JSON object") {
        JsonObject obj;

        WHEN("Adding string values") {
            obj["name"] = "Alice";
            obj["email"] = "alice@example.com";

            THEN("Object contains the values") {
                JsonValue json(obj);
                REQUIRE(json["name"].as_string() == "Alice");
                REQUIRE(json["email"].as_string() == "alice@example.com");
            }
        }

        WHEN("Adding nested objects") {
            obj["user"] = JsonObject{
                {"id", 1},
                {"name", "Bob"}
            };

            THEN("Nested values are accessible") {
                JsonValue json(obj);
                REQUIRE(json["user"]["id"].as_number() == Catch::Approx(1));
                REQUIRE(json["user"]["name"].as_string() == "Bob");
            }
        }

        WHEN("Adding arrays") {
            obj["numbers"] = JsonArray{1, 2, 3, 4, 5};

            THEN("Array elements are accessible") {
                JsonValue json(obj);
                REQUIRE(json["numbers"].size() == 5);
                REQUIRE(json["numbers"][2].as_number() == Catch::Approx(3));
            }
        }
    }
}

TEST_CASE("Error handling", "[errors]") {
    SECTION("Invalid JSON throws exception") {
        REQUIRE_THROWS_AS(Json::parse("{invalid}"), JsonError);
        REQUIRE_THROWS_AS(Json::parse("[1,2,]"), JsonError);
        REQUIRE_THROWS_AS(Json::parse(""), JsonError);
    }

    SECTION("Type mismatch throws exception") {
        auto json = Json::parse(R"({"value": "string"})");

        REQUIRE_THROWS_AS(json["value"].as_number(), std::bad_variant_access);
    }
}

TEST_CASE("Unicode handling", "[unicode]") {
    SECTION("Unicode strings") {
        std::string json = R"({"text": "Hello, \u4e16\u754c"})";
        auto parsed = Json::parse(json);

        REQUIRE_THAT(parsed["text"].as_string(), ContainsSubstring("Hello"));
    }

    SECTION("Emoji") {
        std::string json = R"({"emoji": "\ud83d\ude00"})";
        auto parsed = Json::parse(json);

        // 应该正确处理代理对
        REQUIRE_FALSE(parsed["emoji"].as_string().empty());
    }
}

TEST_CASE("Large JSON handling", "[performance]") {
    SECTION("Large array") {
        JsonArray large_array;
        for (int i = 0; i < 10000; ++i) {
            large_array.push_back(i);
        }

        JsonValue json(large_array);
        auto serialized = json.dump();
        auto reparsed = Json::parse(serialized);

        REQUIRE(reparsed.size() == 10000);
    }

    SECTION("Deeply nested structure") {
        std::string json = "0";
        for (int i = 0; i < 100; ++i) {
            json = "[" + json + "]";
        }

        auto parsed = Json::parse(json);
        REQUIRE(parsed.is_array());
    }
}
```

---

## 月度验收标准

### 知识验收（口头回答或笔记）

- [ ] 1. EXPECT和ASSERT断言的区别是什么？各在什么场景使用？
- [ ] 2. GTest测试夹具的生命周期是怎样的？SetUp和SetUpTestSuite有何区别？
- [ ] 3. 参数化测试中Values/Range/ValuesIn/Combine生成器各适用什么场景？
- [ ] 4. Catch2的SECTION是如何实现测试隔离的？与GTest的TEST_F有何不同？
- [ ] 5. GTest和Catch2各有什么优劣势？如何选择？
- [ ] 6. Mock/Stub/Fake/Spy四种测试替身的区别是什么？
- [ ] 7. 什么时候应该使用Mock？什么时候Mock是过度使用？
- [ ] 8. 依赖注入如何提升代码可测试性？请举例说明。
- [ ] 9. FIRST原则的每个字母代表什么？为什么重要？
- [ ] 10. TDD红绿重构循环的三个步骤各要做什么？

### 实践验收（代码检查）

- [ ] 能独立搭建GTest + CMake项目并运行测试
- [ ] 能编写涵盖六类断言的测试用例
- [ ] 能编写参数化测试（值参数化和类型参数化）
- [ ] 能搭建Catch2 v3项目并使用SECTION组织测试
- [ ] 能编写BDD风格的Catch2测试
- [ ] 能使用GMock进行接口Mock和行为验证
- [ ] 能使用TDD方法开发简单功能（如JSON解析器部分功能）
- [ ] 能配置和生成代码覆盖率报告（gcov/lcov）
- [ ] 能使用命令行参数进行测试过滤和调试
- [ ] JSON解析器项目通过所有测试且覆盖率 > 80%

---

## 知识地图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Month 42: 单元测试知识地图                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│                          ┌────────────────┐                                 │
│                          │  单元测试       │                                 │
│                          │  (Unit Testing)│                                 │
│                          └───────┬────────┘                                 │
│                                  │                                          │
│              ┌───────────────────┼───────────────────┐                      │
│              │                   │                   │                      │
│              ▼                   ▼                   ▼                      │
│     ┌────────────────┐  ┌────────────────┐  ┌────────────────┐             │
│     │  Google Test   │  │   Catch2       │  │  测试设计       │             │
│     └───────┬────────┘  └───────┬────────┘  └───────┬────────┘             │
│             │                   │                   │                      │
│     ┌───────┴───────┐   ┌──────┴───────┐   ┌──────┴───────┐              │
│     │               │   │              │   │              │              │
│     ▼               ▼   ▼              ▼   ▼              ▼              │
│  ┌──────┐     ┌──────┐ ┌──────┐  ┌──────┐ ┌──────┐  ┌──────┐           │
│  │断言  │     │夹具  │ │SECTION│  │Matcher│ │Mock  │  │TDD   │           │
│  │系统  │     │体系  │ │机制  │  │系统  │ │对象  │  │流程  │           │
│  └──┬───┘     └──┬───┘ └──┬───┘  └──┬───┘ └──┬───┘  └──┬───┘           │
│     │            │        │         │        │         │               │
│     ▼            ▼        ▼         ▼        ▼         ▼               │
│  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐  ┌──────┐          │
│  │6类   │  │SetUp │  │嵌套  │  │内置  │  │GMock │  │红绿  │          │
│  │断言  │  │生命  │  │执行  │  │自定义│  │匹配器│  │重构  │          │
│  │      │  │周期  │  │路径  │  │      │  │序列  │  │循环  │          │
│  └──────┘  └──────┘  └──────┘  └──────┘  └──────┘  └──────┘          │
│                                                                             │
│  ┌──────────────────────┐  ┌──────────────────────┐                        │
│  │   参数化测试          │  │   质量保证工具        │                        │
│  │   ┌──────┬──────┐    │  │   ┌──────┬──────┐    │                        │
│  │   │值参数│类型  │    │  │   │覆盖率│CI    │    │                        │
│  │   │化    │参数化│    │  │   │工具  │集成  │    │                        │
│  │   ├──────┼──────┤    │  │   ├──────┼──────┤    │                        │
│  │   │生成器│模板  │    │  │   │gcov  │FIRST │    │                        │
│  │   │组合  │测试  │    │  │   │lcov  │原则  │    │                        │
│  │   └──────┴──────┘    │  │   └──────┴──────┘    │                        │
│  └──────────────────────┘  └──────────────────────┘                        │
│                                                                             │
│  关联知识：                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Month 37 (CMake)     │ CMake + CTest + GTest 集成                   │   │
│  │ Month 38 (vcpkg)     │ 依赖管理: gtest, catch2 安装                 │   │
│  │ Month 40 (CI/CD)     │ 自动化测试 + 覆盖率报告                      │   │
│  │ Month 41 (Docker)    │ 容器化测试环境                                │   │
│  │ Month 43 (静态分析)  │ 代码质量的另一维度                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 完整输出物清单

| 序号 | 类别 | 文件/目录 | 说明 |
|------|------|-----------|------|
| 1 | 项目 | `gtest_basics/CMakeLists.txt` | GTest + CMake集成模板 |
| 2 | 项目 | `gtest_basics/vcpkg.json` | 依赖声明 |
| 3 | 代码 | `gtest_basics/test_assertions.cpp` | 六类断言完整示例 |
| 4 | 代码 | `gtest_basics/test_fixtures.cpp` | 测试夹具各种模式 |
| 5 | 代码 | `parameterized/test_values.cpp` | 值参数化测试示例 |
| 6 | 代码 | `parameterized/test_combine.cpp` | 组合参数化测试示例 |
| 7 | 代码 | `parameterized/test_typed.cpp` | 类型参数化测试示例 |
| 8 | 代码 | `parameterized/test_file_based.cpp` | 外部数据驱动测试 |
| 9 | 项目 | `catch2_tests/CMakeLists.txt` | Catch2 v3 + CMake配置 |
| 10 | 代码 | `catch2_tests/test_sections.cpp` | SECTION嵌套示例 |
| 11 | 代码 | `catch2_tests/test_matchers.cpp` | 内置与自定义Matcher |
| 12 | 代码 | `catch2_tests/test_generators.cpp` | Generator示例 |
| 13 | 代码 | `catch2_tests/test_bdd.cpp` | BDD风格测试 |
| 14 | 代码 | `mock_tests/test_mock_basic.cpp` | GMock基础示例 |
| 15 | 代码 | `mock_tests/test_order_processor.cpp` | 完整Mock集成测试 |
| 16 | 代码 | `mock_tests/test_doubles.cpp` | 测试替身模式示例 |
| 17 | 项目 | `json-parser/` | TDD方式开发的JSON解析器 |
| 18 | 配置 | `cmake/Coverage.cmake` | 覆盖率CMake模块 |
| 19 | 报告 | `coverage_report/` | HTML覆盖率报告 |
| 20 | 脚本 | `scripts/run_tests.sh` | 测试运行与过滤脚本 |
| 21 | 笔记 | `notes/week1_gtest_basics.md` | GTest核心概念 |
| 22 | 笔记 | `notes/week2_parameterized.md` | 参数化测试总结 |
| 23 | 笔记 | `notes/week3_catch2.md` | Catch2核心概念 |
| 24 | 笔记 | `notes/week4_mock_tdd.md` | Mock和TDD总结 |
| 25 | 笔记 | `notes/gtest_vs_catch2.md` | 框架选型决策 |
| 26 | 笔记 | `notes/month42_testing.md` | 月度学习总结 |

---

## 时间分配表

| 周次 | 主题 | 理论学习 | 实践编码 | 源码阅读 | 合计 |
|------|------|----------|----------|----------|------|
| 第1周 | Google Test基础 | 12h | 18h | 5h | 35h |
| 第2周 | 参数化测试与类型测试 | 10h | 20h | 5h | 35h |
| 第3周 | Catch2框架 | 10h | 20h | 5h | 35h |
| 第4周 | Mock与测试设计 | 8h | 22h | 5h | 35h |
| **合计** | | **40h** | **80h** | **20h** | **140h** |

---

## 下月预告

Month 43将学习**Clang-Tidy静态分析**，掌握代码质量检查和自动修复技术。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Month 42 → Month 43 衔接                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Month 42: 单元测试              Month 43: Clang-Tidy静态分析              │
│  ┌─────────────────────┐        ┌─────────────────────┐                    │
│  │ • GTest/Catch2      │        │ • Clang-Tidy配置    │                    │
│  │ • Mock对象          │───────▶│ • 检查规则体系      │                    │
│  │ • TDD流程           │        │ • 自动修复          │                    │
│  │ • 代码覆盖率        │        │ • CI集成            │                    │
│  └─────────────────────┘        └─────────────────────┘                    │
│                                                                             │
│  衔接点：                                                                    │
│  • 单元测试验证代码行为正确 → 静态分析发现代码质量问题                       │
│  • 覆盖率报告CI集成 → 静态分析CI集成                                        │
│  • 测试驱动开发 → 质量驱动开发                                              │
│  • 二者结合构成完整的代码质量保障体系                                        │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │              代码质量保障金字塔                                       │   │
│  │                                                                     │   │
│  │                    ┌─────┐                                          │   │
│  │                   ╱ Code ╲                                          │   │
│  │                  ╱ Review ╲          ← 人工审查                     │   │
│  │                 ╱───────────╲                                       │   │
│  │                ╱  Static    ╲                                       │   │
│  │               ╱  Analysis   ╲       ← Month 43                     │   │
│  │              ╱───────────────╲                                      │   │
│  │             ╱   Unit Tests    ╲     ← Month 42 ★当前               │   │
│  │            ╱───────────────────╲                                    │   │
│  │           ╱  Compiler Warnings  ╲   ← 基础                         │   │
│  │          ╱───────────────────────╲                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```
